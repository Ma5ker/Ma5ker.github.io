<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="结合源码对内存分配的流程进行分析。">
<meta property="og:type" content="article">
<meta property="og:title" content="堆溢出(2)-堆内存分配操作流程">
<meta property="og:url" content="http://yoursite.com/2020/05/25/heapOverflow2/index.html">
<meta property="og:site_name" content="sec4fun">
<meta property="og:description" content="结合源码对内存分配的流程进行分析。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-05-25T08:46:42.000Z">
<meta property="article:modified_time" content="2020-06-21T13:19:24.000Z">
<meta property="article:author" content="ma5ker">
<meta property="article:tag" content="pwn">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/2020/05/25/heapOverflow2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>堆溢出(2)-堆内存分配操作流程 | sec4fun</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">sec4fun</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc"><span class="nav-number">1.</span> <span class="nav-text">malloc</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#libc-malloc"><span class="nav-number">1.1.</span> <span class="nav-text">__libc_malloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#int-malloc"><span class="nav-number">1.2.</span> <span class="nav-text">_int_malloc</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#free"><span class="nav-number">2.</span> <span class="nav-text">free</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#libc-free"><span class="nav-number">2.1.</span> <span class="nav-text">__libc_free</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#int-free"><span class="nav-number">2.2.</span> <span class="nav-text">_int_free</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc-consolidate"><span class="nav-number">3.</span> <span class="nav-text">malloc_consolidate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unlink-chunk"><span class="nav-number">4.</span> <span class="nav-text">unlink_chunk</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ma5ker"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">ma5ker</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Ma5ker" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ma5ker" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kcahlb@gmail.com" title="E-Mail → mailto:kcahlb@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/25/heapOverflow2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="ma5ker">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sec4fun">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          堆溢出(2)-堆内存分配操作流程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-25 16:46:42" itemprop="dateCreated datePublished" datetime="2020-05-25T16:46:42+08:00">2020-05-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-06-21 21:19:24" itemprop="dateModified" datetime="2020-06-21T21:19:24+08:00">2020-06-21</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CTF/" itemprop="url" rel="index"><span itemprop="name">CTF</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>45k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>41 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>结合源码对内存分配的流程进行分析。</p>
<a id="more"></a>

<p>谈到linux内存分配，关键的就是malloc和free两个函数，下面主要分析这两个函数源码总结堆内存分配的流程。当然其中还涉及到<code>malloc_consolidate</code>等函数，也会在后面分析其作用过程。部分源码比较长，意思写在注释里面了，不想看可以直接看源码后的流程总结部分。</p>
<h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><p>malloc是c语言中常用的内存申请函数，<code>__libc_malloc</code>为其在glibc中的实现。下面是glibc中<code>__libc_malloc</code>代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*malloc 在glibc的实现  其更底层是_int_malloc*&#x2F;</span><br><span class="line">void *</span><br><span class="line">__libc_malloc (size_t bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;&#x2F;*malloc_state指针*&#x2F;</span><br><span class="line">  void *victim;</span><br><span class="line"></span><br><span class="line">  _Static_assert (PTRDIFF_MAX &lt;&#x3D; SIZE_MAX &#x2F; 2,</span><br><span class="line">                  &quot;PTRDIFF_MAX is not more than half of SIZE_MAX&quot;);</span><br><span class="line">  &#x2F;*检查是否有内存分配钩子*&#x2F;</span><br><span class="line">  void *(*hook) (size_t, const void *)</span><br><span class="line">    &#x3D; atomic_forced_read (__malloc_hook);</span><br><span class="line">  if (__builtin_expect (hook !&#x3D; NULL, 0))</span><br><span class="line">    return (*hook)(bytes, RETURN_ADDRESS (0));</span><br><span class="line">#if USE_TCACHE</span><br><span class="line">  &#x2F;* int_free also calls request2size, be careful to not pad twice.  *&#x2F;</span><br><span class="line"></span><br><span class="line">  size_t tbytes;</span><br><span class="line">  &#x2F;*根据传入的参数计算chunk大小，得到tcache对应的下标*&#x2F;</span><br><span class="line">  if (!checked_request2size (bytes, &amp;tbytes))</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (ENOMEM);</span><br><span class="line">      return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">  size_t tc_idx &#x3D; csize2tidx (tbytes);&#x2F;*转为tcache 的index*&#x2F;</span><br><span class="line">  &#x2F;*初始化 tcache*&#x2F;</span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  if (tc_idx &lt; mp_.tcache_bins&#x2F;&#x2F;根据size得到的idx在合法的范围内</span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;counts[tc_idx] &gt; 0)&#x2F;&#x2F;对应的tcache 链不为空</span><br><span class="line">    &#123;</span><br><span class="line">      return tcache_get (tc_idx);&#x2F;&#x2F;转入tcache获取</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  if (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim &#x3D; _int_malloc (&amp;main_arena, bytes);</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">	      &amp;main_arena &#x3D;&#x3D; arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      return victim;</span><br><span class="line">    &#125;</span><br><span class="line">  &#x2F;*寻找一个 arena 来试图分配内存，并上锁，宏位于arena.c *&#x2F;</span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  &#x2F;*调用 _int_malloc 函数申请对应大小的内存*&#x2F;</span><br><span class="line">  victim &#x3D; _int_malloc (ar_ptr, bytes);</span><br><span class="line">  &#x2F;* Retry with another arena only if we were able to find a usable arena</span><br><span class="line">     before.  *&#x2F;</span><br><span class="line">  if (!victim &amp;&amp; ar_ptr !&#x3D; NULL)</span><br><span class="line">  &#x2F;*如果分配失败的话，ptmalloc 会再次尝试*&#x2F;</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, 1, bytes);</span><br><span class="line">      ar_ptr &#x3D; arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim &#x3D; _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">  &#x2F;*如果申请到了 arena，退出前解锁*&#x2F;</span><br><span class="line">  if (ar_ptr !&#x3D; NULL)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line">  &#x2F;*断言目前状态满足以下条件之一*&#x2F;</span><br><span class="line">  &#x2F;* 没有申请到内存</span><br><span class="line">   * mmap的内存</span><br><span class="line">   * 申请到的内存必须在其所分配的arena中</span><br><span class="line">   *&#x2F;</span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr &#x3D;&#x3D; arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  &#x2F;*返回内存*&#x2F;</span><br><span class="line">  return victim;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_malloc)</span><br></pre></td></tr></table></figure>

<p>总结逻辑</p>
<ul>
<li>检查是否有内存分配钩子函数，有的话调用之</li>
<li>如果启用了tcache会先计算tcache的索引看对应的tcache链是否为空，不为空就从中获取一个chunk使用</li>
<li>寻找一个 arena 来试图分配内存，并上锁</li>
<li>调用<code>_int_malloc</code>函数申请对应大小的内存</li>
<li>失败后再次尝试</li>
<li>断言执行后的可能出现的三种意外情况，如果出现则报错退出<ul>
<li>没有申请到内存</li>
<li>mmap得到的内存</li>
<li>申请到的内存不在其所分配的arena中</li>
</ul>
</li>
<li>返回申请的内存区域指针</li>
</ul>
<p>其中有一点可以看到，tcache作为亲儿子，检查是优先于其他所有的bin的，这是做启用tcache的libc相关堆题时需要注意的。</p>
<h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h3><p>除此之外，malloc对内存申请的主要逻辑基本都在<code>_int_malloc</code>，下面看其源码，源码比较长，给了关键部分的注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">   ------------------------------ malloc ------------------------------</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;*真实的malloc存在*&#x2F;</span><br><span class="line">static void *</span><br><span class="line">_int_malloc (mstate av, size_t bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               &#x2F;* normalized request size *&#x2F;</span><br><span class="line">  unsigned int idx;                 &#x2F;* associated bin index *&#x2F;</span><br><span class="line">  mbinptr bin;                      &#x2F;* associated bin *&#x2F;</span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 &#x2F;* inspected&#x2F;selected chunk *&#x2F;</span><br><span class="line">  INTERNAL_SIZE_T size;             &#x2F;* its size *&#x2F;</span><br><span class="line">  int victim_index;                 &#x2F;* its bin index *&#x2F;</span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              &#x2F;* remainder from a split *&#x2F;</span><br><span class="line">  unsigned long remainder_size;     &#x2F;* its size *&#x2F;</span><br><span class="line"></span><br><span class="line">  unsigned int block;               &#x2F;* bit map traverser *&#x2F;</span><br><span class="line">  unsigned int bit;                 &#x2F;* bit map traverser *&#x2F;</span><br><span class="line">  unsigned int map;                 &#x2F;* current word of binmap *&#x2F;</span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    &#x2F;* misc temp for linking *&#x2F;</span><br><span class="line">  mchunkptr bck;                    &#x2F;* misc temp for linking *&#x2F;</span><br><span class="line"></span><br><span class="line">#if USE_TCACHE</span><br><span class="line">  size_t tcache_unsorted_count;	    &#x2F;* count of unsorted chunks processed *&#x2F;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">     Convert request size to internal form by adding SIZE_SZ bytes</span><br><span class="line">     overhead plus possibly more to obtain necessary alignment and&#x2F;or</span><br><span class="line">     to obtain a size of at least MINSIZE, the smallest allocatable</span><br><span class="line">     size. Also, checked_request2size returns false for request sizes</span><br><span class="line">     that are so large that they wrap around zero when padded and</span><br><span class="line">     aligned.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  &#x2F;*检查请求  将请求大小转为chunk对齐后的大小*&#x2F;</span><br><span class="line">  if (!checked_request2size (bytes, &amp;nb))</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (ENOMEM);</span><br><span class="line">      return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span><br><span class="line">     mmap.  *&#x2F;</span><br><span class="line">  &#x2F;*无可用arena*&#x2F;</span><br><span class="line">  if (__glibc_unlikely (av &#x3D;&#x3D; NULL))</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;*调用sysmalloc申请*&#x2F;</span><br><span class="line">      void *p &#x3D; sysmalloc (nb, av);</span><br><span class="line">      if (p !&#x3D; NULL)</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">     If the size qualifies as a fastbin, first check corresponding bin.</span><br><span class="line">     This code is safe to execute even if av is not yet initialized, so we</span><br><span class="line">     can try it without checking, which saves some time on this fast path.</span><br><span class="line">   *&#x2F;</span><br><span class="line"></span><br><span class="line">#define REMOVE_FB(fb, victim, pp)			\</span><br><span class="line">  do							\</span><br><span class="line">    &#123;							\</span><br><span class="line">      victim &#x3D; pp;					\</span><br><span class="line">      if (victim &#x3D;&#x3D; NULL)				\</span><br><span class="line">	break;						\</span><br><span class="line">    &#125;							\</span><br><span class="line">  while ((pp &#x3D; catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span><br><span class="line">	 !&#x3D; victim);					\</span><br><span class="line">  &#x2F;*如果大小小于fastbin，从fastbin中获取合适大小*&#x2F;</span><br><span class="line">  if ((unsigned long) (nb) &lt;&#x3D; (unsigned long) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;*计算大小对应的fastbin 索引*&#x2F;</span><br><span class="line">      idx &#x3D; fastbin_index (nb);</span><br><span class="line">      &#x2F;*对应的fastbin链的头指针*&#x2F;</span><br><span class="line">      mfastbinptr *fb &#x3D; &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim &#x3D; *fb;</span><br><span class="line">      &#x2F;*判断此fastbin链是不是空的*&#x2F;</span><br><span class="line">      if (victim !&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">	  if (SINGLE_THREAD_P)</span><br><span class="line">	    *fb &#x3D; victim-&gt;fd;</span><br><span class="line">	  else</span><br><span class="line">    &#x2F;*利用fd遍历对应的bin内是否有空闲的chunk块*&#x2F;</span><br><span class="line">	    REMOVE_FB (fb, pp, victim);</span><br><span class="line">    &#x2F;*存在一个可用的chunk*&#x2F;</span><br><span class="line">	  if (__glibc_likely (victim !&#x3D; NULL))</span><br><span class="line">	    &#123;</span><br><span class="line">        &#x2F;*判断这个chunk的size与其fastbin链所在的索引index是否是相对应的*&#x2F;</span><br><span class="line">        &#x2F;*就是这里导致了在fastbin伪造chunk时由write-anything-anywhere转为了受限地址的任意写入*&#x2F;</span><br><span class="line">	      size_t victim_idx &#x3D; fastbin_index (chunksize (victim));</span><br><span class="line">	      if (__builtin_expect (victim_idx !&#x3D; idx, 0))</span><br><span class="line">		malloc_printerr (&quot;malloc(): memory corruption (fast)&quot;);</span><br><span class="line">        &#x2F;*调试状态下进行的细致的检查*&#x2F;</span><br><span class="line">	      check_remalloced_chunk (av, victim, nb);</span><br><span class="line">        &#x2F;*这部分是使用tcache的逻辑*&#x2F;</span><br><span class="line">#if USE_TCACHE</span><br><span class="line">	      &#x2F;* While we&#39;re here, if we see other chunks of the same size,</span><br><span class="line">		 stash them in the tcache.  *&#x2F;</span><br><span class="line">     &#x2F;*找对应的tcache索引*&#x2F;</span><br><span class="line">	      size_t tc_idx &#x3D; csize2tidx (nb);</span><br><span class="line">	      if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">		&#123;</span><br><span class="line">		  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">		  &#x2F;* While bin not empty and tcache not full, copy chunks.  *&#x2F;</span><br><span class="line">      &#x2F;*tcache没满 放进去填满*&#x2F;</span><br><span class="line">		  while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">			 &amp;&amp; (tc_victim &#x3D; *fb) !&#x3D; NULL)</span><br><span class="line">		    &#123;</span><br><span class="line">		      if (SINGLE_THREAD_P)</span><br><span class="line">			*fb &#x3D; tc_victim-&gt;fd;</span><br><span class="line">		      else</span><br><span class="line">			&#123;</span><br><span class="line">			  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">			  if (__glibc_unlikely (tc_victim &#x3D;&#x3D; NULL))</span><br><span class="line">			    break;</span><br><span class="line">			&#125;</span><br><span class="line">		      tcache_put (tc_victim, tc_idx);</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">#endif</span><br><span class="line">        &#x2F;*找到可用chunk  转为mem指针输出*&#x2F;</span><br><span class="line">	      void *p &#x3D; chunk2mem (victim);</span><br><span class="line">        &#x2F;* 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff*&#x2F;</span><br><span class="line">	      alloc_perturb (p, bytes);</span><br><span class="line">	      return p;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="line">     hold one size each, no searching within bins is necessary.</span><br><span class="line">     (For a large request, we need to wait until unsorted chunks are</span><br><span class="line">     processed to find best fit. But for small ones, fits are exact</span><br><span class="line">     anyway, so we can check now, which is faster.)</span><br><span class="line">   *&#x2F;</span><br><span class="line">  &#x2F;*如果大小位于small bin中的话  得到位于的smallbin索引 *&#x2F;</span><br><span class="line">  if (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;*获取small bin对应的索引*&#x2F;</span><br><span class="line">      idx &#x3D; smallbin_index (nb);</span><br><span class="line">      &#x2F;*找到对应的bin*&#x2F;</span><br><span class="line">      bin &#x3D; bin_at (av, idx);</span><br><span class="line">      &#x2F;*获取其最后一个chunk 如果为bin 则说明bin是空的 否则有下面两个情况*&#x2F;</span><br><span class="line">      if ((victim &#x3D; last (bin)) !&#x3D; bin)</span><br><span class="line">        &#123;</span><br><span class="line">          bck &#x3D; victim-&gt;bk;</span><br><span class="line">        &#x2F;*bin不为空  检查这个chunk的尾部chunk的前一个chunk 防止出现伪造*&#x2F;</span><br><span class="line">	  if (__glibc_unlikely (bck-&gt;fd !&#x3D; victim))</span><br><span class="line">	    malloc_printerr (&quot;malloc(): smallbin double linked list corrupted&quot;);</span><br><span class="line">          &#x2F;*设置inuse位*&#x2F;</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          &#x2F;* 修改对应的bin链表将 small bin 的最后一个 chunk 取出来*&#x2F;</span><br><span class="line">          bin-&gt;bk &#x3D; bck;</span><br><span class="line">          bck-&gt;fd &#x3D; bin;</span><br><span class="line"></span><br><span class="line">          if (av !&#x3D; &amp;main_arena)</span><br><span class="line">	    set_non_main_arena (victim);</span><br><span class="line">      &#x2F;*调试状态下进行的细致的检查*&#x2F;</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">#if USE_TCACHE</span><br><span class="line">	  &#x2F;* While we&#39;re here, if we see other chunks of the same size,</span><br><span class="line">	     stash them in the tcache.  *&#x2F;</span><br><span class="line">       &#x2F;*当从这个small bin中找到一个可用chunk后，会把bin上其他的所有chunk都放入tcache*&#x2F;</span><br><span class="line">	  size_t tc_idx &#x3D; csize2tidx (nb);</span><br><span class="line">	  if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">	    &#123;</span><br><span class="line">	      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	      &#x2F;* While bin not empty and tcache not full, copy chunks over.  *&#x2F;</span><br><span class="line">	      while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">		     &amp;&amp; (tc_victim &#x3D; last (bin)) !&#x3D; bin)</span><br><span class="line">		&#123;</span><br><span class="line">		  if (tc_victim !&#x3D; 0)</span><br><span class="line">		    &#123;</span><br><span class="line">          &#x2F;*这里是先从链上取下chunk，类似于unlink操作，不过相比之下更加的简单，没有安全检查  tcache smallbin unlink操作的漏洞原因*&#x2F;</span><br><span class="line">		      bck &#x3D; tc_victim-&gt;bk;</span><br><span class="line">		      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">		      if (av !&#x3D; &amp;main_arena)</span><br><span class="line">			set_non_main_arena (tc_victim);</span><br><span class="line">		      bin-&gt;bk &#x3D; bck;</span><br><span class="line">		      bck-&gt;fd &#x3D; bin;</span><br><span class="line">          &#x2F;*将取下的chunk放入tcache中*&#x2F;</span><br><span class="line">		      tcache_put (tc_victim, tc_idx);</span><br><span class="line">	            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">#endif</span><br><span class="line">          &#x2F;*找到可用chunk  转为mem指针输出*&#x2F;</span><br><span class="line">          void *p &#x3D; chunk2mem (victim);</span><br><span class="line">          &#x2F;* 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff*&#x2F;</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          return p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">     If this is a large request, consolidate fastbins before continuing.</span><br><span class="line">     While it might look excessive to kill all fastbins before</span><br><span class="line">     even seeing if there is space available, this avoids</span><br><span class="line">     fragmentation problems normally associated with fastbins.</span><br><span class="line">     Also, in practice, programs tend to have runs of either small or</span><br><span class="line">     large requests, but less often mixtures, so consolidation is not</span><br><span class="line">     invoked all that often in most programs. And the programs that</span><br><span class="line">     it is called frequently in otherwise tend to fragment.</span><br><span class="line">   *&#x2F;</span><br><span class="line"></span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;*获取size对应的large bin中的索引*&#x2F;</span><br><span class="line">      idx &#x3D; largebin_index (nb);</span><br><span class="line">      &#x2F;*如果存在fastbin的话，会处理(合并所有的)fastbin *&#x2F;</span><br><span class="line">      if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">     Process recently freed or remaindered chunks, taking one only if</span><br><span class="line">     it is exact fit, or, if this a small request, the chunk is remainder from</span><br><span class="line">     the most recent non-exact fit.  Place other traversed chunks in</span><br><span class="line">     bins.  Note that this step is the only place in any routine where</span><br><span class="line">     chunks are placed in bins.</span><br><span class="line">     The outer loop here is needed because we might not realize until</span><br><span class="line">     near the end of malloc that we should have consolidated, so must</span><br><span class="line">     do so and retry. This happens at most once, and only when we would</span><br><span class="line">     otherwise need to expand memory to service a &quot;small&quot; request.</span><br><span class="line">   *&#x2F;</span><br><span class="line"></span><br><span class="line">#if USE_TCACHE</span><br><span class="line">  INTERNAL_SIZE_T tcache_nb &#x3D; 0;</span><br><span class="line">  size_t tc_idx &#x3D; csize2tidx (nb);</span><br><span class="line">  if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    tcache_nb &#x3D; nb;</span><br><span class="line">  int return_cached &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  tcache_unsorted_count &#x3D; 0;</span><br><span class="line">#endif</span><br><span class="line">  &#x2F;*大循环遍历unsorted bin  大致逻辑如下*&#x2F;</span><br><span class="line">  &#x2F;*</span><br><span class="line">   * 按照 FIFO 的方式逐个将 unsorted bin 中的 chunk 取出来</span><br><span class="line">   * 如果是 small request，则考虑是不是恰好满足，是的话，直接返回</span><br><span class="line">   * 如果不是的话，放到对应的 bin 中</span><br><span class="line">   * 尝试从 large bin 中分配用户所需的内存</span><br><span class="line">   *  -- from ctf-wiki  不一定正确</span><br><span class="line">   *&#x2F;</span><br><span class="line">  for (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      int iters &#x3D; 0;</span><br><span class="line">      &#x2F;*unsorted bin不为空时*&#x2F;</span><br><span class="line">      while ((victim &#x3D; unsorted_chunks (av)-&gt;bk) !&#x3D; unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          &#x2F;*victim为unsorted bin的最后一个chunk*&#x2F;</span><br><span class="line">          &#x2F;*bck设置为unsorted bin的倒数第二一个chunk*&#x2F;</span><br><span class="line">          bck &#x3D; victim-&gt;bk;</span><br><span class="line">          &#x2F;*获取chunk的size*&#x2F;</span><br><span class="line">          size &#x3D; chunksize (victim);</span><br><span class="line">          &#x2F;*获取下一个chunk*&#x2F;</span><br><span class="line">          mchunkptr next &#x3D; chunk_at_offset (victim, size);</span><br><span class="line">          &#x2F;*判断当前chunk以及下一个chunk各项信息是否合法*&#x2F;</span><br><span class="line">          if (__glibc_unlikely (size &lt;&#x3D; 2 * SIZE_SZ)</span><br><span class="line">              || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (&quot;malloc(): invalid size (unsorted)&quot;);</span><br><span class="line">          if (__glibc_unlikely (chunksize_nomask (next) &lt; 2 * SIZE_SZ)</span><br><span class="line">              || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (&quot;malloc(): invalid next size (unsorted)&quot;);</span><br><span class="line">          if (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) !&#x3D; size))</span><br><span class="line">            malloc_printerr (&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;);</span><br><span class="line">          if (__glibc_unlikely (bck-&gt;fd !&#x3D; victim)</span><br><span class="line">              || __glibc_unlikely (victim-&gt;fd !&#x3D; unsorted_chunks (av)))</span><br><span class="line">            malloc_printerr (&quot;malloc(): unsorted double linked list corrupted&quot;);</span><br><span class="line">          if (__glibc_unlikely (prev_inuse (next)))</span><br><span class="line">            malloc_printerr (&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;);</span><br><span class="line"></span><br><span class="line">          &#x2F;*</span><br><span class="line">             If a small request, try to use last remainder if it is the</span><br><span class="line">             only chunk in unsorted bin.  This helps promote locality for</span><br><span class="line">             runs of consecutive small requests. This is the only</span><br><span class="line">             exception to best-fit, and applies only when there is</span><br><span class="line">             no exact fit for a small chunk.</span><br><span class="line">           *&#x2F;</span><br><span class="line">          &#x2F;*用户的请求为 small bin chunk  先考虑是否unsorted bin中只有last remainder*&#x2F;</span><br><span class="line">          if (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck &#x3D;&#x3D; unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim &#x3D;&#x3D; av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              &#x2F;* split and reattach remainder *&#x2F;</span><br><span class="line">              &#x2F;*新remainder的大小*&#x2F;</span><br><span class="line">              remainder_size &#x3D; size - nb;</span><br><span class="line">              &#x2F;*获取新的 remainder 的位置*&#x2F;</span><br><span class="line">              remainder &#x3D; chunk_at_offset (victim, nb);</span><br><span class="line">              &#x2F;*更新unsorted bin*&#x2F;</span><br><span class="line">              unsorted_chunks (av)-&gt;bk &#x3D; unsorted_chunks (av)-&gt;fd &#x3D; remainder;</span><br><span class="line">              &#x2F;*更新malloc_state中记录的last remainder*&#x2F;</span><br><span class="line">              av-&gt;last_remainder &#x3D; remainder;</span><br><span class="line">              &#x2F;*更新remainder的指针*&#x2F;</span><br><span class="line">              remainder-&gt;bk &#x3D; remainder-&gt;fd &#x3D; unsorted_chunks (av);</span><br><span class="line">              if (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize &#x3D; NULL;</span><br><span class="line">                  remainder-&gt;bk_nextsize &#x3D; NULL;</span><br><span class="line">                &#125;</span><br><span class="line">              &#x2F;*设置victim chunk的头部*&#x2F;</span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av !&#x3D; &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">              &#x2F;*设置 remainder 的头部*&#x2F;</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              &#x2F;*设置记录remainder大小的prev_size字段，因为处于空闲状态*&#x2F;</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              &#x2F;*chunk转为mem指针*&#x2F;</span><br><span class="line">              void *p &#x3D; chunk2mem (victim);</span><br><span class="line">              &#x2F;*chunk初始化*&#x2F;</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              return p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          &#x2F;* remove from unsorted list *&#x2F;</span><br><span class="line">          if (__glibc_unlikely (bck-&gt;fd !&#x3D; victim))</span><br><span class="line">            malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);</span><br><span class="line">          &#x2F;*取出chunk*&#x2F;</span><br><span class="line">          unsorted_chunks (av)-&gt;bk &#x3D; bck;</span><br><span class="line">          bck-&gt;fd &#x3D; unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          &#x2F;* Take now instead of binning if exact fit *&#x2F;</span><br><span class="line">          &#x2F;*如果大小合适  直接使用*&#x2F;</span><br><span class="line">          if (size &#x3D;&#x3D; nb)</span><br><span class="line">            &#123;</span><br><span class="line">              &#x2F;*设置*&#x2F;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              if (av !&#x3D; &amp;main_arena)</span><br><span class="line">		set_non_main_arena (victim);</span><br><span class="line">#if USE_TCACHE</span><br><span class="line">	      &#x2F;* Fill cache first, return to user only if cache fills.</span><br><span class="line">		 We may return one of these chunks later.  *&#x2F;</span><br><span class="line">     &#x2F;*向tcache中放*&#x2F;</span><br><span class="line">	      if (tcache_nb</span><br><span class="line">		  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">		&#123;</span><br><span class="line">		  tcache_put (victim, tc_idx);</span><br><span class="line">      &#x2F;*标志位，被置位说明满足要求的chunk被放入tcache中了，后面以此判断是否需要从tcache中取*&#x2F;</span><br><span class="line">		  return_cached &#x3D; 1;</span><br><span class="line">		  continue;</span><br><span class="line">		&#125;</span><br><span class="line">	      else</span><br><span class="line">		&#123;</span><br><span class="line">#endif</span><br><span class="line">              &#x2F;* 调试时细致检查*&#x2F;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              &#x2F;*chunk转为mem指针返回*&#x2F;</span><br><span class="line">              void *p &#x3D; chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              return p;</span><br><span class="line">#if USE_TCACHE</span><br><span class="line">		&#125;</span><br><span class="line">#endif</span><br><span class="line">            &#125;</span><br><span class="line">          &#x2F;*当前chunk不符合要求时  整理chunk*&#x2F;</span><br><span class="line">          &#x2F;* place chunk in bin *&#x2F;</span><br><span class="line">          &#x2F;*如果chunk在small bin大小范围  整理后放回small bin*&#x2F;</span><br><span class="line">          if (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index &#x3D; smallbin_index (size);</span><br><span class="line">              bck &#x3D; bin_at (av, victim_index);</span><br><span class="line">              fwd &#x3D; bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          else&#x2F;*否则 取出来放入large bin  下面是对应的放入large bin逻辑*&#x2F;</span><br><span class="line">            &#123;</span><br><span class="line">              &#x2F;*对应的large bin的索引*&#x2F;</span><br><span class="line">              victim_index &#x3D; largebin_index (size);</span><br><span class="line">              bck &#x3D; bin_at (av, victim_index);&#x2F;&#x2F; 当前的large bin 的头部</span><br><span class="line">              fwd &#x3D; bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              &#x2F;* maintain large bins in sorted order *&#x2F;</span><br><span class="line">              &#x2F;*下面部分暗示了每个  large bin是从大到小排列的*&#x2F;</span><br><span class="line">              &#x2F;*large bin不是空的*&#x2F;</span><br><span class="line">              if (fwd !&#x3D; bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  &#x2F;* Or with inuse bit to speed comparisons *&#x2F;</span><br><span class="line">                  size |&#x3D; PREV_INUSE;</span><br><span class="line">                  &#x2F;* if smaller than smallest, bypass loop below *&#x2F;</span><br><span class="line">                  &#x2F;*bck-&gt;bk 存储着相应 large bin 中最小的chunk  如果比这个还小，只需要插入到链表尾部*&#x2F;</span><br><span class="line">                  assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                  if ((unsigned long) (size)</span><br><span class="line">		      &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd &#x3D; bck;&#x2F;&#x2F;fwd 指向 large bin 头部</span><br><span class="line">                      bck &#x3D; bck-&gt;bk;&#x2F;&#x2F;bck 指向 largin bin 尾部 chunk</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize &#x3D; fwd-&gt;fd;&#x2F;&#x2F;victim 的 fd_nextsize 指向 largin bin 的第一个 chunk</span><br><span class="line">                      victim-&gt;bk_nextsize &#x3D; fwd-&gt;fd-&gt;bk_nextsize;&#x2F;&#x2F;victim 的 bk_nextsize 指向原来链表的第一个 chunk 指向的 bk_nextsize</span><br><span class="line">                      &#x2F;*原来链表的第一个 chunk 的 bk_nextsize 指向 victim*&#x2F;</span><br><span class="line">                      &#x2F;*原来指向链表第一个 chunk 的 fd_nextsize 指向 victim*&#x2F; </span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize &#x3D; victim-&gt;bk_nextsize-&gt;fd_nextsize &#x3D; victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  else&#x2F;&#x2F;当前要插入的 victim 的大小大于最小的 chunk</span><br><span class="line">                    &#123;</span><br><span class="line">                      assert (chunk_main_arena (fwd));</span><br><span class="line">                      &#x2F;&#x2F;从链表头部开始找比victim小于或等于的chunk</span><br><span class="line">                      while ((unsigned long) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd &#x3D; fwd-&gt;fd_nextsize;</span><br><span class="line">			  assert (chunk_main_arena (fwd));</span><br><span class="line">                        &#125;</span><br><span class="line">                      &#x2F;*如果找到个相等的，就直接将 chunk 插入到该chunk的后面，不改变nextsize指针*&#x2F;</span><br><span class="line">                      if ((unsigned long) size</span><br><span class="line">			  &#x3D;&#x3D; (unsigned long) chunksize_nomask (fwd))</span><br><span class="line">                        &#x2F;* Always insert in the second position.  *&#x2F;</span><br><span class="line">                        fwd &#x3D; fwd-&gt;fd;</span><br><span class="line">                      else&#x2F;&#x2F;如果找到的chunk和当前victim大小不一样，需要构造双向链表将当前的chunk链进去</span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize &#x3D; fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize &#x3D; fwd-&gt;bk_nextsize;</span><br><span class="line">                          if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize !&#x3D; fwd))</span><br><span class="line">                            malloc_printerr (&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;);</span><br><span class="line">                          fwd-&gt;bk_nextsize &#x3D; victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize &#x3D; victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck &#x3D; fwd-&gt;bk;</span><br><span class="line">                      if (bck-&gt;fd !&#x3D; fwd)</span><br><span class="line">                        malloc_printerr (&quot;malloc(): largebin double linked list corrupted (bk)&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              else&#x2F;&#x2F;对应的large bin是空的话，直接让fd_nextsize与bk_nextsize构成双向链表</span><br><span class="line">                victim-&gt;fd_nextsize &#x3D; victim-&gt;bk_nextsize &#x3D; victim;</span><br><span class="line">            &#125;</span><br><span class="line">          &#x2F;*对应的 bin的binmap进行标记，并修改这个bin的链表*&#x2F;</span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk &#x3D; bck;</span><br><span class="line">          victim-&gt;fd &#x3D; fwd;</span><br><span class="line">          fwd-&gt;bk &#x3D; victim;</span><br><span class="line">          bck-&gt;fd &#x3D; victim;</span><br><span class="line"></span><br><span class="line">#if USE_TCACHE</span><br><span class="line">      &#x2F;* If we&#39;ve processed as many chunks as we&#39;re allowed while</span><br><span class="line">	 filling the cache, return one of the cached ones.  *&#x2F;</span><br><span class="line">   </span><br><span class="line">   &#x2F;*设置一个清理上限，清理到一定次数就不再清理了*&#x2F;</span><br><span class="line">      ++tcache_unsorted_count;</span><br><span class="line">      if (return_cached</span><br><span class="line">	  &amp;&amp; mp_.tcache_unsorted_limit &gt; 0</span><br><span class="line">	  &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">	&#123;</span><br><span class="line">	  return tcache_get (tc_idx);</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line">        &#x2F;*这个清理过程最多迭代10000次  超过后退出*&#x2F;</span><br><span class="line">#define MAX_ITERS       10000</span><br><span class="line">          if (++iters &gt;&#x3D; MAX_ITERS)</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">#if USE_TCACHE</span><br><span class="line">      &#x2F;* If all the small chunks we found ended up cached, return one now.  *&#x2F;</span><br><span class="line">      if (return_cached)</span><br><span class="line">	&#123;</span><br><span class="line">    &#x2F;*根据前面的标志说明tcache中已经有了满足要求的small chunk，从tcache中取出一个给用户使用*&#x2F;</span><br><span class="line">	  return tcache_get (tc_idx);</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">      &#x2F;*</span><br><span class="line">         If a large request, scan through the chunks of current bin in</span><br><span class="line">         sorted order to find smallest that fits.  Use the skip list for this.</span><br><span class="line">       *&#x2F;</span><br><span class="line">      &#x2F;*明确一下  进行到这里 前面从unsorted bin中对chunk进行了回收 仍然没发现可用的chunk   这意味着small bin中的chunk都不符合*&#x2F;</span><br><span class="line">      &#x2F;*在large chunk中开始搜索*&#x2F;</span><br><span class="line">      if (!in_smallbin_range (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          &#x2F;*获得对应的bin*&#x2F;</span><br><span class="line">          bin &#x3D; bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">          &#x2F;* skip scan if empty or largest chunk is too small *&#x2F;</span><br><span class="line">          &#x2F;&#x2F;如果对应的 bin为空或者其中的chunk最大的也很小，那就跳过</span><br><span class="line">          if ((victim &#x3D; first (bin)) !&#x3D; bin</span><br><span class="line">	      &amp;&amp; (unsigned long) chunksize_nomask (victim)</span><br><span class="line">	        &gt;&#x3D; (unsigned long) (nb))</span><br><span class="line">            &#123;</span><br><span class="line">              &#x2F;*反向遍历链表 直到找到一个不小于需要申请大小的chunk*&#x2F;</span><br><span class="line">              victim &#x3D; victim-&gt;bk_nextsize;</span><br><span class="line">              while (((unsigned long) (size &#x3D; chunksize (victim)) &lt;</span><br><span class="line">                      (unsigned long) (nb)))</span><br><span class="line">                victim &#x3D; victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">              &#x2F;* Avoid removing the first entry for a size so that the skip</span><br><span class="line">                 list does not have to be rerouted.  *&#x2F;</span><br><span class="line">              &#x2F;* 这边是一个简化操作的技巧  如果找到的chunk并不是最后一个 而且其前面还有大小与它相同的，那就</span><br><span class="line">               * 取它前面的那个chunk  这样就可以避免调整bk_nextsize</span><br><span class="line">               * 因为一个bin中同样大小的chunk 只有一个会被链在bk_nextsize上</span><br><span class="line">               *&#x2F;</span><br><span class="line">              if (victim !&#x3D; last (bin)</span><br><span class="line">		  &amp;&amp; chunksize_nomask (victim)</span><br><span class="line">		    &#x3D;&#x3D; chunksize_nomask (victim-&gt;fd))</span><br><span class="line">                victim &#x3D; victim-&gt;fd;</span><br><span class="line">              &#x2F;*计算分配和剩余的大小*&#x2F;</span><br><span class="line">              remainder_size &#x3D; size - nb;</span><br><span class="line">              &#x2F;*将chunk unlink出来*&#x2F;</span><br><span class="line">              unlink_chunk (av, victim);</span><br><span class="line"></span><br><span class="line">              &#x2F;* Exhaust *&#x2F;</span><br><span class="line">              &#x2F;*剩下的大小不足以当做一个chunk*&#x2F;</span><br><span class="line">              if (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  &#x2F;*好像并没进行其他操作*&#x2F;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  if (av !&#x3D; &amp;main_arena)</span><br><span class="line">		    set_non_main_arena (victim);</span><br><span class="line">                &#125;</span><br><span class="line">              &#x2F;* Split *&#x2F;</span><br><span class="line">              else</span><br><span class="line">                &#123;</span><br><span class="line">                  &#x2F;*如果剩下的还能构成一个chunk  就分裂它  获取剩下的部分的指针 *&#x2F;</span><br><span class="line">                  remainder &#x3D; chunk_at_offset (victim, nb);</span><br><span class="line">                  &#x2F;* We cannot assume the unsorted list is empty and therefore</span><br><span class="line">                     have to perform a complete insert here.  *&#x2F;</span><br><span class="line">                  &#x2F;*获取unsorted bin的头部与第一个chunk，准备链入unsorted bin*&#x2F;</span><br><span class="line">                  bck &#x3D; unsorted_chunks (av);</span><br><span class="line">                  fwd &#x3D; bck-&gt;fd;</span><br><span class="line">                  &#x2F;*先判断unsorted bin是不是被破坏了*&#x2F;</span><br><span class="line">		  if (__glibc_unlikely (fwd-&gt;bk !&#x3D; bck))</span><br><span class="line">		    malloc_printerr (&quot;malloc(): corrupted unsorted chunks&quot;);</span><br><span class="line">                  &#x2F;*链入unsorted bin*&#x2F;</span><br><span class="line">                  remainder-&gt;bk &#x3D; bck;</span><br><span class="line">                  remainder-&gt;fd &#x3D; fwd;</span><br><span class="line">                  bck-&gt;fd &#x3D; remainder;</span><br><span class="line">                  fwd-&gt;bk &#x3D; remainder;</span><br><span class="line">                  &#x2F;*这个剩余的chunk如果不在small bin范围的话 设置对应的字段*&#x2F;</span><br><span class="line">                  if (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize &#x3D; NULL;</span><br><span class="line">                      remainder-&gt;bk_nextsize &#x3D; NULL;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#x2F;*设置分裂出来的两个chunk的头部*&#x2F;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av !&#x3D; &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  &#x2F;*设置remainder的大小*&#x2F;</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              &#x2F;*老三样*&#x2F;</span><br><span class="line">              &#x2F;*调试时会进行的细致检查*&#x2F;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              &#x2F;*chunk指针转为mem指针*&#x2F;</span><br><span class="line">              void *p &#x3D; chunk2mem (victim);</span><br><span class="line">              &#x2F;*chunk初始填充*&#x2F;</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              return p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;*</span><br><span class="line">         Search for a chunk by scanning bins, starting with next largest</span><br><span class="line">         bin. This search is strictly by best-fit; i.e., the smallest</span><br><span class="line">         (with ties going to approximately the least recently used) chunk</span><br><span class="line">         that fits is selected.</span><br><span class="line">         The bitmap avoids needing to check that most blocks are nonempty.</span><br><span class="line">         The particular case of skipping all bins during warm-up phases</span><br><span class="line">         when no chunks have been returned yet is faster than it might look.</span><br><span class="line">       *&#x2F;</span><br><span class="line">      &#x2F;*到这里  如果还没找到可用的chunk  意味着large bin也无能为力*&#x2F;</span><br><span class="line">      &#x2F;*尝试增加idx来寻找*&#x2F;</span><br><span class="line">      ++idx;</span><br><span class="line">      &#x2F;*获取对应的bin*&#x2F;</span><br><span class="line">      bin &#x3D; bin_at (av, idx);</span><br><span class="line">      &#x2F;*这一段有点没懂  binmap是标记bin是否为空的 这里是可以通过这样对所有的bin做统一处理吗？*&#x2F;</span><br><span class="line">      &#x2F;*当前索引在binmap中的block索引  从而找到对应的map #define idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)  ,BINMAPSHIFT&#x3D;5</span><br><span class="line">       *前面说过一个map是32位  所以需要右移5</span><br><span class="line">       *&#x2F;</span><br><span class="line">      block &#x3D; idx2block (idx);</span><br><span class="line">      map &#x3D; av-&gt;binmap[block];</span><br><span class="line">      bit &#x3D; idx2bit (idx);&#x2F;&#x2F;idx对应的位设置为1，其它位为0</span><br><span class="line">      &#x2F;*上述过程就是计算了idx应该对应的map 以及自己的bit  以进行比较*&#x2F;</span><br><span class="line"></span><br><span class="line">      for (;; )</span><br><span class="line">        &#123;</span><br><span class="line">          &#x2F;* Skip rest of block if there are no more set bits in this block.  *&#x2F;</span><br><span class="line">          &#x2F;*如果bit&gt;map，则表示该 map 中没有比当前所需要chunk大的空闲块*&#x2F;</span><br><span class="line">          &#x2F;*而如果bit等于0 那表示上面idx2bit的参数为0*&#x2F;</span><br><span class="line">          if (bit &gt; map || bit &#x3D;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">              do&#x2F;*寻找下一个block，直到其对应的map不为0*&#x2F;</span><br><span class="line">                &#123;</span><br><span class="line">                  &#x2F;*如果bllock超出了binmap的大小  说明还是找不到 那就需要去top chunk找了*&#x2F;</span><br><span class="line">                  if (++block &gt;&#x3D; BINMAPSIZE) &#x2F;* out of bins *&#x2F;</span><br><span class="line">                    goto use_top;</span><br><span class="line">                &#125;</span><br><span class="line">              while ((map &#x3D; av-&gt;binmap[block]) &#x3D;&#x3D; 0);</span><br><span class="line">              &#x2F;* 找到了map，获取对应的bin，因为该map中的chunk大小都比所需的chunk大(idx先自增了)，而且</span><br><span class="line">               * map本身不为0，所以这个map所在的所有bin中必然存在合适的一个chunk。*&#x2F;</span><br><span class="line">              bin &#x3D; bin_at (av, (block &lt;&lt; BINMAPSHIFT));&#x2F;*这个bin是map的最小bin  因为index最小*&#x2F;</span><br><span class="line">              bit &#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          &#x2F;* Advance to bin with set bit. There must be one. *&#x2F;</span><br><span class="line">          &#x2F;*从最小bin找，直到找到合适的bin  前面说过 这个过程必然能找到*&#x2F;</span><br><span class="line">          while ((bit &amp; map) &#x3D;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">              bin &#x3D; next_bin (bin);</span><br><span class="line">              bit &lt;&lt;&#x3D; 1;</span><br><span class="line">              assert (bit !&#x3D; 0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          &#x2F;* Inspect the bin. It is likely to be non-empty *&#x2F;</span><br><span class="line">          &#x2F;*获取对应的bin*&#x2F;</span><br><span class="line">          victim &#x3D; last (bin);</span><br><span class="line"></span><br><span class="line">          &#x2F;*  If a false alarm (empty bin), clear the bit. *&#x2F;</span><br><span class="line">          &#x2F;*如果victim&#x3D;bin，那么我们就将map对应的位清0，然后获取下一个bin*&#x2F;</span><br><span class="line">          &#x2F;*victim等于bin说明这个bin是空的 不可能啊？*&#x2F;</span><br><span class="line">          if (victim &#x3D;&#x3D; bin)</span><br><span class="line">            &#123;</span><br><span class="line">              av-&gt;binmap[block] &#x3D; map &amp;&#x3D; ~bit; &#x2F;* Write through *&#x2F;</span><br><span class="line">              bin &#x3D; next_bin (bin);</span><br><span class="line">              bit &lt;&lt;&#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          else</span><br><span class="line">            &#123;</span><br><span class="line">              &#x2F;*获取chunk的size*&#x2F;</span><br><span class="line">              size &#x3D; chunksize (victim);</span><br><span class="line"></span><br><span class="line">              &#x2F;*  We know the first chunk in this bin is big enough to use. *&#x2F;</span><br><span class="line">              assert ((unsigned long) (size) &gt;&#x3D; (unsigned long) (nb));</span><br><span class="line">              &#x2F;*计算分割后剩余的大小*&#x2F;</span><br><span class="line">              remainder_size &#x3D; size - nb;</span><br><span class="line"></span><br><span class="line">              &#x2F;* unlink *&#x2F;</span><br><span class="line">              unlink_chunk (av, victim);</span><br><span class="line"></span><br><span class="line">              &#x2F;* Exhaust *&#x2F;</span><br><span class="line">              &#x2F;*跟上面逻辑一样 分割后不够一个chunk的  这也没写怎么处理的呀？*&#x2F;</span><br><span class="line">              if (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  if (av !&#x3D; &amp;main_arena)</span><br><span class="line">		    set_non_main_arena (victim);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              &#x2F;* Split *&#x2F;</span><br><span class="line">              else&#x2F;*分裂后还能够一个chunk  那就分裂它*&#x2F;</span><br><span class="line">                &#123;&#x2F;*计算剩余的chunk的偏移*&#x2F;</span><br><span class="line">                  remainder &#x3D; chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">                  &#x2F;* We cannot assume the unsorted list is empty and therefore</span><br><span class="line">                     have to perform a complete insert here.  *&#x2F;</span><br><span class="line">                  &#x2F;*将剩余的chunk插入到unsorted bin*&#x2F;</span><br><span class="line">                  bck &#x3D; unsorted_chunks (av);</span><br><span class="line">                  fwd &#x3D; bck-&gt;fd;</span><br><span class="line">		  if (__glibc_unlikely (fwd-&gt;bk !&#x3D; bck))</span><br><span class="line">		    malloc_printerr (&quot;malloc(): corrupted unsorted chunks 2&quot;);</span><br><span class="line">                  remainder-&gt;bk &#x3D; bck;</span><br><span class="line">                  remainder-&gt;fd &#x3D; fwd;</span><br><span class="line">                  bck-&gt;fd &#x3D; remainder;</span><br><span class="line">                  fwd-&gt;bk &#x3D; remainder;</span><br><span class="line"></span><br><span class="line">                  &#x2F;* advertise as last remainder *&#x2F;</span><br><span class="line">                  &#x2F;* 如果在small bin范围内，就将其标记为remainder*&#x2F;</span><br><span class="line">                  if (in_smallbin_range (nb))</span><br><span class="line">                    av-&gt;last_remainder &#x3D; remainder;</span><br><span class="line">                  if (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize &#x3D; NULL;</span><br><span class="line">                      remainder-&gt;bk_nextsize &#x3D; NULL;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#x2F;*设置老三样*&#x2F;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av !&#x3D; &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              &#x2F;*继续老三样*&#x2F;</span><br><span class="line">              void *p &#x3D; chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              return p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    use_top:&#x2F;*这部分开始使用top chunk*&#x2F;</span><br><span class="line">      &#x2F;*</span><br><span class="line">         If large enough, split off the chunk bordering the end of memory</span><br><span class="line">         (held in av-&gt;top). Note that this is in accord with the best-fit</span><br><span class="line">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span><br><span class="line">         less well fitting) than any other available chunk since it can</span><br><span class="line">         be extended to be as large as necessary (up to system</span><br><span class="line">         limitations).</span><br><span class="line">         We require that av-&gt;top always exists (i.e., has size &gt;&#x3D;</span><br><span class="line">         MINSIZE) after initialization, so if it would otherwise be</span><br><span class="line">         exhausted by current request, it is replenished. (The main</span><br><span class="line">         reason for ensuring it exists is that we may need MINSIZE space</span><br><span class="line">         to put in fenceposts in sysmalloc.)</span><br><span class="line">       *&#x2F;</span><br><span class="line">      &#x2F;*获取top chunk*&#x2F;</span><br><span class="line">      victim &#x3D; av-&gt;top;</span><br><span class="line">      &#x2F;*top chunk大小*&#x2F;</span><br><span class="line">      size &#x3D; chunksize (victim);</span><br><span class="line"></span><br><span class="line">      if (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">        malloc_printerr (&quot;malloc(): corrupted top size&quot;);</span><br><span class="line">      &#x2F;*top chunk很大  分裂完还是满足  需要大小+最小chunk大小  那就分裂它*&#x2F;</span><br><span class="line">      if ((unsigned long) (size) &gt;&#x3D; (unsigned long) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size &#x3D; size - nb;</span><br><span class="line">          remainder &#x3D; chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top &#x3D; remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av !&#x3D; &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          void *p &#x3D; chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          return p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;* When we are using atomic ops to free fast chunks we can get</span><br><span class="line">         here for all block sizes.  *&#x2F;</span><br><span class="line">      &#x2F;*否则就判断是否有 fast chunk*&#x2F;</span><br><span class="line">      else if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        &#123;</span><br><span class="line">          &#x2F;*先进行fastbin合并*&#x2F;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          &#x2F;* restore original bin index *&#x2F;</span><br><span class="line">          &#x2F;*</span><br><span class="line">           * 判断需要的chunk是在small bin范围还是large bin范围  然后计算对应的索引</span><br><span class="line">           * </span><br><span class="line">           **&#x2F;</span><br><span class="line">          if (in_smallbin_range (nb))</span><br><span class="line">            idx &#x3D; smallbin_index (nb);</span><br><span class="line">          else</span><br><span class="line">            idx &#x3D; largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;*</span><br><span class="line">         Otherwise, relay to handle system-dependent cases</span><br><span class="line">       *&#x2F;</span><br><span class="line">      else&#x2F;*进行到这  就说明堆内存不够了 需要调用sysmalloc来申请内存*&#x2F;</span><br><span class="line">        &#123;</span><br><span class="line">          void *p &#x3D; sysmalloc (nb, av);</span><br><span class="line">          if (p !&#x3D; NULL)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          return p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下大致的流程：</p>
<ul>
<li>检查是否有可用的arena，没有的话就向调用sysmalloc申请，有的话就继续下一步</li>
<li>如果小于fastbin最大size，尝试从fastbin获取合适大小的chunk，转换为mem指针输出<ul>
<li>根据size计算index得到对应的fastbin chunk链，不为空则取头部</li>
<li>如果启用了tcache则看此链是否存在其他chunk，全放入tcache直到到达上限(7个)</li>
<li>注意这部分对找到的chunk做了size与链的所在index是否对应的判断，所以在fastbin中塞入伪造chunk时需要注意size字段</li>
</ul>
</li>
<li>如果fastbin中没找到，大小在small bin范围，则前往small bin查找<ul>
<li>根据size计算index得到所对应的smallbin的 chunk链，判断是否为空(并检查尾部chunk和其上一个chunk的前后项指针防止伪造)，最后取出尾部的chunk</li>
<li>同样的如果启用tcache则用剩下的chunk填满对应的tcache链</li>
</ul>
</li>
<li>到这一步，先使用<code>malloc_consolidate</code>函数合并当前arena下所有的fastbin</li>
<li>开始处理unsorted bin，按照 FIFO 的方式逐个将 unsorted bin 中的 chunk 取出来做判断<ul>
<li>判断chunk本身信息是否合法，主要是下面几个方面<ul>
<li>size在合法范围</li>
<li>以size作为偏移得到的下一个chunk的size是否合法</li>
<li>下一个chunk的prev_size是不是与当前size相等</li>
<li>fd指针是不是正确</li>
<li>下一个chunk的prev_inuse位是否正确</li>
</ul>
</li>
<li>如果用户请求的small bin chunk，而unsorted bin中只有last_remainder,并且其size足够大，就分裂它返回，并更新malloc_state中的last_remainder记录</li>
<li>检查当前chunk的bk指向chunk的fd指针是否正确(防止伪造)</li>
<li>将chunk取出来<ul>
<li>如果大小合适，放入tcache后继续，设置<code>return_cached</code>表明后面可以从tcache中获取chunk<ul>
<li>如果tcache填满则直接返回这个chunk</li>
</ul>
</li>
<li>chunk大小不对，按照大小范围放回smallbin和largebin<ul>
<li>放回largebin时有两点需要注意<ul>
<li>每个largebin链内部按从大到小排列</li>
<li>如果链中不存在大小相同的，需要将chunk插入fd_nextsize和bk_next_size组成的链表(有相同大小不需要此步，意味着next_size链中只存放不同大小的chunk)</li>
</ul>
</li>
</ul>
</li>
<li>修改对应的binmap</li>
<li>根据<code>return_cached</code>去判断是否前往tcache取chunk</li>
<li>至此还未找到chunk，前往largebin中找<ul>
<li>找到对应的largebin链：如果chunk链为空或者其中的chunk都很小就跳过；否则就反向遍历找一个满足要求大小的chunk，然后分裂这个chunk返回，并将剩余的放入unsorted bin</li>
<li>大小对应的chunk链没找到就循环增加index去更大的chunk链找</li>
<li>还是找不到满足的就去top chunk找，topchunk满足就分裂后返回</li>
<li>堆内存不够了，调用sysmalloc来申请内存</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>做题速览精简版，简化了下逻辑</p>
<ul>
<li>根据size找到tcache的索引，对应的链表不为空就直接拆下来，并将tcache链计数器减一</li>
<li>tcache没找到，就前往fastbin中</li>
<li>size 小于fastbin  找fastbin 找到，填满tcache 然后结束</li>
<li>size在small bin范围中，找small chunk，找到，填满tcache 然后结束</li>
<li>都不在，合并所有fastbin</li>
<li>循环<ul>
<li>检查unsorted bin的last_remainder，满足一定条件，分裂之，剩余的标记为last_remainder</li>
<li>在unsorted bin搜索<ul>
<li>遇到精确大小填充先tcache ，否则就放回small bin/large bin(整理垃圾)</li>
<li>在tcache中找 找到就返回 不行就进行下一步</li>
<li>在small/large bin找合适大小的chunk(large bin中的不一定是精确大小)<ul>
<li>分裂找到的chunk，将合适大小的chunk填入返回，剩余的放入unsorted bin</li>
</ul>
</li>
</ul>
</li>
<li>使用top chunk</li>
<li>向系统申请</li>
</ul>
</li>
</ul>
<h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><h3 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h3><p>free用来释放一片内存区域，与之对应的libc实现是<code>__libc_free</code>，源码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">__libc_free (void *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          &#x2F;* chunk corresponding to mem *&#x2F;</span><br><span class="line">  &#x2F;*是否有钩子函数 __free_hook*&#x2F;</span><br><span class="line">  void (*hook) (void *, const void *)</span><br><span class="line">    &#x3D; atomic_forced_read (__free_hook);</span><br><span class="line">  if (__builtin_expect (hook !&#x3D; NULL, 0))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (0));</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#x2F;*free一个NULL不起作用*&#x2F;</span><br><span class="line">  if (mem &#x3D;&#x3D; 0)                              &#x2F;* free(0) has no effect *&#x2F;</span><br><span class="line">    return;</span><br><span class="line">  &#x2F;*mem指针转换为chunk指针*&#x2F;</span><br><span class="line">  p &#x3D; mem2chunk (mem);</span><br><span class="line">  &#x2F;*内存是mmap得到的*&#x2F;</span><br><span class="line">  if (chunk_is_mmapped (p))                       &#x2F;* release mmapped memory. *&#x2F;</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;* See if the dynamic brk&#x2F;mmap threshold needs adjusting.</span><br><span class="line">	 Dumped fake mmapped chunks do not affect the threshold.  *&#x2F;</span><br><span class="line">      if (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &lt;&#x3D; DEFAULT_MMAP_THRESHOLD_MAX</span><br><span class="line">	  &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p))</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold &#x3D; chunksize (p);</span><br><span class="line">          mp_.trim_threshold &#x3D; 2 * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#x2F;*初始化tcache MAYBE_INIT_TCACHE()在tcache不为空时无作用*&#x2F;</span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line">  &#x2F;*根据chunk获得分配区的指针*&#x2F;</span><br><span class="line">  ar_ptr &#x3D; arena_for_chunk (p);</span><br><span class="line">  &#x2F;*调用_int_free进行释放*&#x2F;</span><br><span class="line">  _int_free (ar_ptr, p, 0);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_free)</span><br></pre></td></tr></table></figure>

<p><code>__libc_free</code>主要干了这么些事</p>
<ul>
<li>检查是否有内存分配钩子函数，有的话调用之，这与malloc类似</li>
<li>内存是mmap得到的，尝试释放</li>
<li>调用<code>MAYBE_INIT_TCACHE</code>初始化tcache</li>
<li>获得chunk所在arena指针</li>
<li>调用<code>_int_free</code>进行内存释放</li>
</ul>
<h3 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h3><p>由上面流程可以看到，其主要实现逻辑也和malloc相似，在<code>_int_free</code>函数中。下面是<code>_int_free</code>源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">   ------------------------------ free ------------------------------</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;*这部分是真正的free*&#x2F;</span><br><span class="line">static void</span><br><span class="line">_int_free (mstate av, mchunkptr p, int have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T size;        &#x2F;* its size *&#x2F;</span><br><span class="line">  mfastbinptr *fb;             &#x2F;* associated fastbin *&#x2F;</span><br><span class="line">  mchunkptr nextchunk;         &#x2F;* next contiguous chunk *&#x2F;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;    &#x2F;* its size *&#x2F;</span><br><span class="line">  int nextinuse;               &#x2F;* true if nextchunk is used *&#x2F;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;    &#x2F;* size of previous contiguous chunk *&#x2F;</span><br><span class="line">  mchunkptr bck;               &#x2F;* misc temp for linking *&#x2F;</span><br><span class="line">  mchunkptr fwd;               &#x2F;* misc temp for linking *&#x2F;</span><br><span class="line">  &#x2F;*获取size大小*&#x2F;</span><br><span class="line">  size &#x3D; chunksize (p);</span><br><span class="line"></span><br><span class="line">  &#x2F;* Little security check which won&#39;t hurt performance: the</span><br><span class="line">     allocator never wrapps around at the end of the address space.</span><br><span class="line">     Therefore we can exclude some size values which might appear</span><br><span class="line">     here by accident or by &quot;design&quot; from some intruder.  *&#x2F;</span><br><span class="line">  &#x2F;*对指针进行检查  第一个指针大于-size是啥意思？  第二个是判断对齐*&#x2F;</span><br><span class="line">  if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), 0))</span><br><span class="line">    malloc_printerr (&quot;free(): invalid pointer&quot;);</span><br><span class="line">  &#x2F;* We know that each chunk is at least MINSIZE bytes in size or a</span><br><span class="line">     multiple of MALLOC_ALIGNMENT.  *&#x2F;</span><br><span class="line">  &#x2F;*大小没有最小的chunk大或大小不是MALLOC_ALIGNMENT的整数倍*&#x2F;</span><br><span class="line">  if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">    malloc_printerr (&quot;free(): invalid size&quot;);</span><br><span class="line">  &#x2F;*检查chunk是否处于使用状态*&#x2F;</span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line"></span><br><span class="line">#if USE_TCACHE</span><br><span class="line">  &#123;</span><br><span class="line">    &#x2F;*找对应到tcache的index*&#x2F;</span><br><span class="line">    size_t tc_idx &#x3D; csize2tidx (size);</span><br><span class="line">    if (tcache !&#x3D; NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line">	&#x2F;* Check to see if it&#39;s already in the tcache.  *&#x2F;</span><br><span class="line">	tcache_entry *e &#x3D; (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line">	&#x2F;* This test succeeds on double free.  However, we don&#39;t 100%</span><br><span class="line">	   trust it (it also matches random payload data at a 1 in</span><br><span class="line">	   2^&lt;size_t&gt; chance), so verify it&#39;s not an unlikely</span><br><span class="line">	   coincidence before aborting.  *&#x2F;</span><br><span class="line">  &#x2F;*遍历链表看是不是有相同的tcache chunk 防止double free*&#x2F;</span><br><span class="line">	if (__glibc_unlikely (e-&gt;key &#x3D;&#x3D; tcache))</span><br><span class="line">	  &#123;</span><br><span class="line">	    tcache_entry *tmp;</span><br><span class="line">	    LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);</span><br><span class="line">	    for (tmp &#x3D; tcache-&gt;entries[tc_idx];</span><br><span class="line">		 tmp;</span><br><span class="line">		 tmp &#x3D; tmp-&gt;next)</span><br><span class="line">	      if (tmp &#x3D;&#x3D; e)</span><br><span class="line">		malloc_printerr (&quot;free(): double free detected in tcache 2&quot;);</span><br><span class="line">	    &#x2F;* If we get here, it was a coincidence.  We&#39;ve wasted a</span><br><span class="line">	       few cycles, but don&#39;t abort.  *&#x2F;</span><br><span class="line">	  &#125;</span><br><span class="line">  &#x2F;*如果对应的tcache链没满  就是小于7个  那就调用tcache_put放进去*&#x2F;</span><br><span class="line">	if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">	  &#123;</span><br><span class="line">	    tcache_put (p, tc_idx);&#x2F;*直接放回对应tcache链的头部，也没有对放入的chunk的inuse置位*&#x2F;</span><br><span class="line">	    return;</span><br><span class="line">	  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">    If eligible, place chunk on a fastbin so it can be found</span><br><span class="line">    and used quickly in malloc.</span><br><span class="line">  *&#x2F;</span><br><span class="line">  &#x2F;*判断是不是在 fast bin 范围*&#x2F;</span><br><span class="line">  if ((unsigned long)(size) &lt;&#x3D; (unsigned long)(get_max_fast ())</span><br><span class="line"></span><br><span class="line">#if TRIM_FASTBINS</span><br><span class="line">      &#x2F;*</span><br><span class="line">	If TRIM_FASTBINS set, don&#39;t place chunks</span><br><span class="line">	bordering top into fastbins</span><br><span class="line">      *&#x2F;</span><br><span class="line">      &#x2F;*此chunk是fast chunk，并且下一个chunk是top chunk，则不能插入*&#x2F;</span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) !&#x3D; av-&gt;top)</span><br><span class="line">#endif</span><br><span class="line">      ) &#123;</span><br><span class="line">    &#x2F;*下一个chunk的大小不能小于两倍的SIZE_SZ,并且下一个chunk的大小不能大于system_mem*&#x2F;</span><br><span class="line">    if (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))</span><br><span class="line">			  &lt;&#x3D; 2 * SIZE_SZ, 0)</span><br><span class="line">	|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">			     &gt;&#x3D; av-&gt;system_mem, 0))</span><br><span class="line">      &#123;</span><br><span class="line">	bool fail &#x3D; true;</span><br><span class="line">	&#x2F;* We might not have a lock at this point and concurrent modifications</span><br><span class="line">	   of system_mem might result in a false positive.  Redo the test after</span><br><span class="line">	   getting the lock.  *&#x2F;</span><br><span class="line">	if (!have_lock)</span><br><span class="line">	  &#123;</span><br><span class="line">	    __libc_lock_lock (av-&gt;mutex);</span><br><span class="line">	    fail &#x3D; (chunksize_nomask (chunk_at_offset (p, size)) &lt;&#x3D; 2 * SIZE_SZ</span><br><span class="line">		    || chunksize (chunk_at_offset (p, size)) &gt;&#x3D; av-&gt;system_mem);</span><br><span class="line">	    __libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	if (fail)</span><br><span class="line">	  malloc_printerr (&quot;free(): invalid next size (fast)&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#x2F;*将chunk的mem设置为perturb_byte*&#x2F;</span><br><span class="line">    free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);</span><br><span class="line">    </span><br><span class="line">    atomic_store_relaxed (&amp;av-&gt;have_fastchunks, true);</span><br><span class="line">    &#x2F;*由size获取fastbin的索引*&#x2F;</span><br><span class="line">    unsigned int idx &#x3D; fastbin_index(size);</span><br><span class="line">    &#x2F;*获取对应fastbin的头指针*&#x2F;</span><br><span class="line">    fb &#x3D; &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">    &#x2F;* Atomically link P to its fastbin: P-&gt;FD &#x3D; *FB; *FB &#x3D; P;  *&#x2F;</span><br><span class="line">    &#x2F;*使用原子操作将P插入到fastbin链表中*&#x2F;</span><br><span class="line">    mchunkptr old &#x3D; *fb, old2;</span><br><span class="line"></span><br><span class="line">    if (SINGLE_THREAD_P)</span><br><span class="line">      &#123;</span><br><span class="line">	&#x2F;* Check that the top of the bin is not the record we are going to</span><br><span class="line">	   add (i.e., double free).  *&#x2F;</span><br><span class="line">	if (__builtin_expect (old &#x3D;&#x3D; p, 0))</span><br><span class="line">	  malloc_printerr (&quot;double free or corruption (fasttop)&quot;);</span><br><span class="line">	p-&gt;fd &#x3D; old;</span><br><span class="line">	*fb &#x3D; p;</span><br><span class="line">      &#125;</span><br><span class="line">    else</span><br><span class="line">      do</span><br><span class="line">	&#123;</span><br><span class="line">	  &#x2F;* Check that the top of the bin is not the record we are going to</span><br><span class="line">	     add (i.e., double free).  *&#x2F;</span><br><span class="line">    &#x2F;*可以看到，对fastbin 的chunk进行free时，只检查了是不是其对应的chunk链的第一个chunk相同，并没有检查是不是与chunk链上的每一个chunk相同*&#x2F;</span><br><span class="line">	  if (__builtin_expect (old &#x3D;&#x3D; p, 0))</span><br><span class="line">	    malloc_printerr (&quot;double free or corruption (fasttop)&quot;);</span><br><span class="line">	  p-&gt;fd &#x3D; old2 &#x3D; old;</span><br><span class="line">	&#125;</span><br><span class="line">      while ((old &#x3D; catomic_compare_and_exchange_val_rel (fb, p, old2))</span><br><span class="line">	     !&#x3D; old2);</span><br><span class="line"></span><br><span class="line">    &#x2F;* Check that size of fastbin chunk at the top is the same as</span><br><span class="line">       size of the chunk that we are adding.  We can dereference OLD</span><br><span class="line">       only if we have the lock, otherwise it might have already been</span><br><span class="line">       allocated again.  *&#x2F;</span><br><span class="line">    if (have_lock &amp;&amp; old !&#x3D; NULL</span><br><span class="line">	&amp;&amp; __builtin_expect (fastbin_index (chunksize (old)) !&#x3D; idx, 0))</span><br><span class="line">      malloc_printerr (&quot;invalid fastbin entry (free)&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">    Consolidate other non-mmapped chunks as they arrive.</span><br><span class="line">  *&#x2F;</span><br><span class="line">  &#x2F;*内存合并部分*&#x2F;</span><br><span class="line">  else if (!chunk_is_mmapped(p)) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;* If we&#39;re single-threaded, don&#39;t lock the arena.  *&#x2F;</span><br><span class="line">    if (SINGLE_THREAD_P)</span><br><span class="line">      have_lock &#x3D; true;</span><br><span class="line">    &#x2F;*先请求锁*&#x2F;</span><br><span class="line">    if (!have_lock)</span><br><span class="line">      __libc_lock_lock (av-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    nextchunk &#x3D; chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    &#x2F;* Lightweight tests: check whether the block is already the</span><br><span class="line">       top block.  *&#x2F;</span><br><span class="line">    &#x2F;*轻量级检测*&#x2F;</span><br><span class="line">    &#x2F;*free的chunk不能是top chunk*&#x2F;</span><br><span class="line">    if (__glibc_unlikely (p &#x3D;&#x3D; av-&gt;top))</span><br><span class="line">      malloc_printerr (&quot;double free or corruption (top)&quot;);</span><br><span class="line">    &#x2F;* Or whether the next chunk is beyond the boundaries of the arena.  *&#x2F;</span><br><span class="line">    &#x2F;*下一个chunk不能超过arena的边界*&#x2F;</span><br><span class="line">    if (__builtin_expect (contiguous (av)</span><br><span class="line">			  &amp;&amp; (char *) nextchunk</span><br><span class="line">			  &gt;&#x3D; ((char *) av-&gt;top + chunksize(av-&gt;top)), 0))</span><br><span class="line">	malloc_printerr (&quot;double free or corruption (out)&quot;);</span><br><span class="line">    &#x2F;* Or whether the block is actually not marked used.  *&#x2F;</span><br><span class="line">    &#x2F;*chunk的使用标记没有被标记 防止double free？*&#x2F;</span><br><span class="line">    if (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">      malloc_printerr (&quot;double free or corruption (!prev)&quot;);</span><br><span class="line">    &#x2F;*下一个chunk的大小*&#x2F;</span><br><span class="line">    nextsize &#x3D; chunksize(nextchunk);</span><br><span class="line">    &#x2F;*下一个chunk的大小是否不大于2*SIZE_SZ，或者nextsize是否大于系统可提供内存*&#x2F;</span><br><span class="line">    if (__builtin_expect (chunksize_nomask (nextchunk) &lt;&#x3D; 2 * SIZE_SZ, 0)</span><br><span class="line">	|| __builtin_expect (nextsize &gt;&#x3D; av-&gt;system_mem, 0))</span><br><span class="line">      malloc_printerr (&quot;free(): invalid next size (normal)&quot;);</span><br><span class="line">    &#x2F;*释放 并填充chunk的mem部分*&#x2F;</span><br><span class="line">    free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    &#x2F;* consolidate backward *&#x2F;</span><br><span class="line">    &#x2F;*后向合并  合并的是比他地址低的chunk*&#x2F;</span><br><span class="line">    if (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize &#x3D; prev_size (p);</span><br><span class="line">      size +&#x3D; prevsize;</span><br><span class="line">      p &#x3D; chunk_at_offset(p, -((long) prevsize));</span><br><span class="line">      if (__glibc_unlikely (chunksize(p) !&#x3D; prevsize))</span><br><span class="line">        malloc_printerr (&quot;corrupted size vs. prev_size while consolidating&quot;);</span><br><span class="line">      unlink_chunk (av, p);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*下一个chunk不是top chunk*&#x2F;</span><br><span class="line">    if (nextchunk !&#x3D; av-&gt;top) &#123;</span><br><span class="line">      &#x2F;* get and clear inuse bit *&#x2F;</span><br><span class="line">      nextinuse &#x3D; inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">    &#x2F;*而且下一个并不inuse  合并掉下一个chunk*&#x2F;</span><br><span class="line">      &#x2F;* consolidate forward *&#x2F;</span><br><span class="line">      if (!nextinuse) &#123;</span><br><span class="line">	unlink_chunk (av, nextchunk);</span><br><span class="line">	size +&#x3D; nextsize;</span><br><span class="line">      &#125; else</span><br><span class="line">	clear_inuse_bit_at_offset(nextchunk, 0);</span><br><span class="line"></span><br><span class="line">      &#x2F;*</span><br><span class="line">	Place the chunk in unsorted chunk list. Chunks are</span><br><span class="line">	not placed into regular bins until after they have</span><br><span class="line">	been given one chance to be used in malloc.</span><br><span class="line">      *&#x2F;</span><br><span class="line">      &#x2F;*合并完放入unsorted bin*&#x2F;</span><br><span class="line">      bck &#x3D; unsorted_chunks(av);</span><br><span class="line">      fwd &#x3D; bck-&gt;fd;</span><br><span class="line">      if (__glibc_unlikely (fwd-&gt;bk !&#x3D; bck))</span><br><span class="line">	malloc_printerr (&quot;free(): corrupted unsorted chunks&quot;);</span><br><span class="line">      p-&gt;fd &#x3D; fwd;</span><br><span class="line">      p-&gt;bk &#x3D; bck;</span><br><span class="line">      &#x2F;* 如果是large chunk，就设置nextsize指针字段为NULL*&#x2F;</span><br><span class="line">      if (!in_smallbin_range(size))</span><br><span class="line">	&#123;</span><br><span class="line">	  p-&gt;fd_nextsize &#x3D; NULL;</span><br><span class="line">	  p-&gt;bk_nextsize &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line">      bck-&gt;fd &#x3D; p;</span><br><span class="line">      fwd-&gt;bk &#x3D; p;</span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">      If the chunk borders the current high end of memory,</span><br><span class="line">      consolidate into top</span><br><span class="line">    *&#x2F;</span><br><span class="line">    &#x2F;*释放的chunk的下一个chunk如果是top chunk，合并到 top chunk*&#x2F;</span><br><span class="line">    else &#123;</span><br><span class="line">      size +&#x3D; nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top &#x3D; p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">      If freeing a large space, consolidate possibly-surrounding</span><br><span class="line">      chunks. Then, if the total unused topmost memory exceeds trim</span><br><span class="line">      threshold, ask malloc_trim to reduce top.</span><br><span class="line">      Unless max_fast is 0, we don&#39;t know if there are fastbins</span><br><span class="line">      bordering top, so we cannot tell for sure whether threshold</span><br><span class="line">      has been reached unless fastbins are consolidated.  But we</span><br><span class="line">      don&#39;t want to consolidate on each free.  As a compromise,</span><br><span class="line">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span><br><span class="line">      is reached.</span><br><span class="line">    *&#x2F;</span><br><span class="line">    &#x2F;*如果合并后的 chunk 的大小大于FASTBIN_CONSOLIDATION_THRESHOLD，向系统返还内存*&#x2F;</span><br><span class="line">    if ((unsigned long)(size) &gt;&#x3D; FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">	malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">      if (av &#x3D;&#x3D; &amp;main_arena) &#123;</span><br><span class="line">#ifndef MORECORE_CANNOT_TRIM</span><br><span class="line">	if ((unsigned long)(chunksize(av-&gt;top)) &gt;&#x3D;</span><br><span class="line">	    (unsigned long)(mp_.trim_threshold))</span><br><span class="line">	  systrim(mp_.top_pad, av);</span><br><span class="line">#endif</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">	&#x2F;* Always try heap_trim(), even if the top chunk is not</span><br><span class="line">	   large, because the corresponding heap might go away.  *&#x2F;</span><br><span class="line">	heap_info *heap &#x3D; heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">	assert(heap-&gt;ar_ptr &#x3D;&#x3D; av);</span><br><span class="line">	heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!have_lock)</span><br><span class="line">      __libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;*</span><br><span class="line">    If the chunk was allocated via mmap, release via munmap().</span><br><span class="line">  *&#x2F;</span><br><span class="line">  &#x2F;*释放 mmap 的 chunk*&#x2F;</span><br><span class="line">  else &#123;</span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑总结如下</p>
<ul>
<li>chunk检查<ul>
<li>大小小于-size(防止符号问题？)</li>
<li>判断对齐</li>
<li>大小没有最小的chunk大或大小不是MALLOC_ALIGNMENT的整数倍</li>
<li>检查chunk是否处于使用状态</li>
</ul>
</li>
<li>启用tcache时找到对应tcache的index<ul>
<li>遍历链表看是不是有相同的tcache chunk 防止double free</li>
<li>对应的tcache链没满就放进去</li>
</ul>
</li>
<li>在 fastbin 范围<ul>
<li>如果下一个chunk是top chunk，不能直接插入</li>
<li>下一个chunk大小合法，就直接插入对应的chunk链结束</li>
</ul>
</li>
<li>前一个chunk是空闲的(这里前一个指的是内存地址上的前一个)，则unlink 前面的chunk，合并两个chunk</li>
<li>后一个chunk是空闲的，unlink 后面的chunk，合并两个chunk </li>
<li>放入unsorted bin</li>
<li>释放 mmap 的 chunk</li>
</ul>
<h2 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h2><p><code>malloc_consolidate</code>函数用在fastbin中的chunk合并过程，下面在源码中简要梳理下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">static void malloc_consolidate(mstate av)</span><br><span class="line">&#123;</span><br><span class="line">  mfastbinptr*    fb;                 &#x2F;* current fastbin being consolidated *&#x2F;</span><br><span class="line">  mfastbinptr*    maxfb;              &#x2F;* last fastbin (for loop control) *&#x2F;</span><br><span class="line">  mchunkptr       p;                  &#x2F;* current chunk being consolidated *&#x2F;</span><br><span class="line">  mchunkptr       nextp;              &#x2F;* next chunk to consolidate *&#x2F;</span><br><span class="line">  mchunkptr       unsorted_bin;       &#x2F;* bin header *&#x2F;</span><br><span class="line">  mchunkptr       first_unsorted;     &#x2F;* chunk to link to *&#x2F;</span><br><span class="line"></span><br><span class="line">  &#x2F;* These have same use as in free() *&#x2F;</span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  int             nextinuse;</span><br><span class="line"></span><br><span class="line">  atomic_store_relaxed (&amp;av-&gt;have_fastchunks, false);</span><br><span class="line"></span><br><span class="line">  unsorted_bin &#x3D; unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">    Remove each chunk from fast bin and consolidate it, placing it</span><br><span class="line">    then in unsorted bin. Among other reasons for doing this,</span><br><span class="line">    placing in unsorted bin avoids needing to calculate actual bins</span><br><span class="line">    until malloc is sure that chunks aren&#39;t immediately going to be</span><br><span class="line">    reused anyway.</span><br><span class="line">  *&#x2F;</span><br><span class="line">  &#x2F;*按照fd顺序遍历fastbins的每一个bin，将bin中的每一个chunk都合并掉*&#x2F;</span><br><span class="line">  maxfb &#x3D; &amp;fastbin (av, NFASTBINS - 1);</span><br><span class="line">  fb &#x3D; &amp;fastbin (av, 0);</span><br><span class="line">  do &#123;</span><br><span class="line">    p &#x3D; atomic_exchange_acq (fb, NULL);</span><br><span class="line">    if (p !&#x3D; 0) &#123;</span><br><span class="line">      do &#123;</span><br><span class="line">	&#123;</span><br><span class="line">	  unsigned int idx &#x3D; fastbin_index (chunksize (p));</span><br><span class="line">	  if ((&amp;fastbin (av, idx)) !&#x3D; fb)</span><br><span class="line">	    malloc_printerr (&quot;malloc_consolidate(): invalid chunk size&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	check_inuse_chunk(av, p);</span><br><span class="line">	nextp &#x3D; p-&gt;fd;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Slightly streamlined version of consolidation code in free() *&#x2F;</span><br><span class="line">	size &#x3D; chunksize (p);</span><br><span class="line">	nextchunk &#x3D; chunk_at_offset(p, size);</span><br><span class="line">	nextsize &#x3D; chunksize(nextchunk);</span><br><span class="line">  &#x2F;*找当前chunk前面的chunk  尝试合并*&#x2F;</span><br><span class="line">	if (!prev_inuse(p)) &#123;</span><br><span class="line">	  prevsize &#x3D; prev_size (p);</span><br><span class="line">	  size +&#x3D; prevsize;</span><br><span class="line">	  p &#x3D; chunk_at_offset(p, -((long) prevsize));</span><br><span class="line">	  if (__glibc_unlikely (chunksize(p) !&#x3D; prevsize))</span><br><span class="line">	    malloc_printerr (&quot;corrupted size vs. prev_size in fastbins&quot;);</span><br><span class="line">	  unlink_chunk (av, p);</span><br><span class="line">	&#125;</span><br><span class="line">  &#x2F;*当前chunk后面的chunk  尝试合并*&#x2F;</span><br><span class="line">	if (nextchunk !&#x3D; av-&gt;top) &#123;</span><br><span class="line">    &#x2F;&#x2F;判断 nextchunk inuse位</span><br><span class="line">	  nextinuse &#x3D; inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">	  if (!nextinuse) &#123;</span><br><span class="line">	    size +&#x3D; nextsize;</span><br><span class="line">	    unlink_chunk (av, nextchunk);</span><br><span class="line">	  &#125; else</span><br><span class="line">      &#x2F;&#x2F;设置 nextchunk 的 prev inuse 为0，表示可以合并当前fast chunk</span><br><span class="line">	    clear_inuse_bit_at_offset(nextchunk, 0);</span><br><span class="line"></span><br><span class="line">	  first_unsorted &#x3D; unsorted_bin-&gt;fd;</span><br><span class="line">	  unsorted_bin-&gt;fd &#x3D; p;</span><br><span class="line">	  first_unsorted-&gt;bk &#x3D; p;</span><br><span class="line"></span><br><span class="line">	  if (!in_smallbin_range (size)) &#123;</span><br><span class="line">	    p-&gt;fd_nextsize &#x3D; NULL;</span><br><span class="line">	    p-&gt;bk_nextsize &#x3D; NULL;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	  set_head(p, size | PREV_INUSE);</span><br><span class="line">	  p-&gt;bk &#x3D; unsorted_bin;</span><br><span class="line">	  p-&gt;fd &#x3D; first_unsorted;</span><br><span class="line">	  set_foot(p, size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	else &#123;</span><br><span class="line">	  size +&#x3D; nextsize;</span><br><span class="line">	  set_head(p, size | PREV_INUSE);</span><br><span class="line">	  av-&gt;top &#x3D; p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      &#125; while ( (p &#x3D; nextp) !&#x3D; 0);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; while (fb++ !&#x3D; maxfb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="unlink-chunk"><a href="#unlink-chunk" class="headerlink" title="unlink_chunk"></a>unlink_chunk</h2><p><code>unlink_chunk</code>函数用于将某个chunk从所在的chunk双向链表上取下来，较早版本的ublink因为安全检查不够充分，导致会出现任意地址读写的情况发生，不过如今已经修复了。下面通过在源码中添加注释的方式说下大致过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Take a chunk off a bin list.  *&#x2F;</span><br><span class="line">&#x2F;*将chunk p 从bin的链表拆下*&#x2F;</span><br><span class="line">&#x2F;*需要注意的</span><br><span class="line"> *</span><br><span class="line"> *(1)其实它并没改变p本身的fd和bk  可用来泄露堆地址或libc地址</span><br><span class="line"> *(2)使用情况</span><br><span class="line"> * 根据ctf-wiki所述，使用场景有4</span><br><span class="line"> *  malloc             从恰好大小合适的 large bin 中获取 chunk&#x2F;从比请求的 chunk 所在的 bin 大的 bin 中取 chunk</span><br><span class="line"> *  free               后向合并，合并物理相邻低地址空闲 chunk&#x2F;前向合并，合并物理相邻高地址空闲 chunk(除了 top chunk)</span><br><span class="line"> *  malloc_consolidate 后向合并，合并物理相邻低地址空闲 chunk&#x2F;前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）</span><br><span class="line"> *  realloc            前向扩展，合并物理相邻高地址空闲 chunk（除了 top chunk）</span><br><span class="line"> **&#x2F;</span><br><span class="line">static void</span><br><span class="line">unlink_chunk (mstate av, mchunkptr p)</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;*检查了当前的size和下一个chunk中储存的prev_size是否对的上*&#x2F;</span><br><span class="line">  if (chunksize (p) !&#x3D; prev_size (next_chunk (p)))</span><br><span class="line">    &#x2F;*glibc malloc 时检测到错误的时候，会调用 malloc_printerr *&#x2F;</span><br><span class="line">    malloc_printerr (&quot;corrupted size vs. prev_size&quot;);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd &#x3D; p-&gt;fd;</span><br><span class="line">  mchunkptr bk &#x3D; p-&gt;bk;</span><br><span class="line">  &#x2F;*检查双链表是不是正确的， 防止简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果  这也是原来unlink利用方式的原理*&#x2F;</span><br><span class="line">  if (__builtin_expect (fd-&gt;bk !&#x3D; p || bk-&gt;fd !&#x3D; p, 0))</span><br><span class="line">    malloc_printerr (&quot;corrupted double-linked list&quot;);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk &#x3D; bk;</span><br><span class="line">  bk-&gt;fd &#x3D; fd;</span><br><span class="line">  &#x2F;*不在small bin中 就是说碰到前面提到的large block的情况 需要判断chunk的后两个字段  就是fd_nextsize 和bk_nextsize*&#x2F;</span><br><span class="line">  &#x2F;*如果P-&gt;fd_nextsize为NULL，表明P未插入到nextsize链表中。*&#x2F;</span><br><span class="line"></span><br><span class="line">  if (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize !&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;*这个检查和前面的chunk检查类似*&#x2F;</span><br><span class="line">      if (p-&gt;fd_nextsize-&gt;bk_nextsize !&#x3D; p</span><br><span class="line">	  || p-&gt;bk_nextsize-&gt;fd_nextsize !&#x3D; p)</span><br><span class="line">	malloc_printerr (&quot;corrupted double-linked list (not small)&quot;);</span><br><span class="line">      &#x2F;*这说明fd不在nextsize链表*&#x2F;</span><br><span class="line">      if (fd-&gt;fd_nextsize &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">    &#x2F;*nextsize双链表是否只有P本身*&#x2F;</span><br><span class="line">	  if (p-&gt;fd_nextsize &#x3D;&#x3D; p)</span><br><span class="line">      &#x2F;*就将p取走*&#x2F;</span><br><span class="line">	    fd-&gt;fd_nextsize &#x3D; fd-&gt;bk_nextsize &#x3D; fd;</span><br><span class="line">	  else</span><br><span class="line">	    &#123;</span><br><span class="line">        &#x2F;*不止p一个 就将FD插入到 nextsize双链表*&#x2F;</span><br><span class="line">	      fd-&gt;fd_nextsize &#x3D; p-&gt;fd_nextsize;</span><br><span class="line">	      fd-&gt;bk_nextsize &#x3D; p-&gt;bk_nextsize;</span><br><span class="line">	      p-&gt;fd_nextsize-&gt;bk_nextsize &#x3D; fd;</span><br><span class="line">	      p-&gt;bk_nextsize-&gt;fd_nextsize &#x3D; fd;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">      else&#x2F;*fd在nextsize链表，直接取p  也就是拆双链表*&#x2F;</span><br><span class="line">	&#123;</span><br><span class="line">	  p-&gt;fd_nextsize-&gt;bk_nextsize &#x3D; p-&gt;bk_nextsize;</span><br><span class="line">	  p-&gt;bk_nextsize-&gt;fd_nextsize &#x3D; p-&gt;fd_nextsize;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是关于堆内存分配的一些东西，后面就要开始看堆溢出的利用姿势了。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/pwn/" rel="tag"># pwn</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/05/21/heapOverflow1/" rel="prev" title="堆溢出(1)-堆基础">
                  <i class="fa fa-chevron-left"></i> 堆溢出(1)-堆基础
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/06/12/v8Config/" rel="next" title="V8配置与常用调试">
                  V8配置与常用调试 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ma5ker</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">270k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:05</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  















  








  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css">

<script>
NexT.utils.loadComments('#gitalk-container', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '0530768cd3819c29f055',
      clientSecret: '9465920674abd65e54adf115c57771a78911b8f4',
      repo        : 'blog-comments',
      owner       : 'Ma5ker',
      admin       : ['Ma5ker'],
      id          : '22339f1b3f0b741459f7934cf3f13913',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":85,"height":200,"hOffset":60,"vOffset":40},"mobile":{"show":true,"scale":0.3,"motion":true},"neat_enable":true,"neat_html":{"enable":true,"exclude":null},"neat_css":{"enable":true,"exclude":["**/*.min.css"]},"neat_js":{"enable":true,"mangle":true,"output":null,"compress":null,"exclude":["**/*.min.js","**/jquery.fancybox.pack.js","**/index.js","**/love.js"]},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
