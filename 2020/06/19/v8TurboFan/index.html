<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="一篇关于v8 TurboFan文章的翻译，原文地址：An Introduction to Speculative Optimization in V8。">
<meta property="og:type" content="article">
<meta property="og:title" content="V8中Speculative Optimization简介">
<meta property="og:url" content="http://yoursite.com/2020/06/19/v8TurboFan/index.html">
<meta property="og:site_name" content="sec4fun">
<meta property="og:description" content="一篇关于v8 TurboFan文章的翻译，原文地址：An Introduction to Speculative Optimization in V8。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/images/Javascript/V8/turbofan_transl/How%20V8%20Works.png">
<meta property="og:image" content="http://yoursite.com/images/Javascript/V8/turbofan_transl/Chrome%20DevTools.png">
<meta property="og:image" content="http://yoursite.com/images/Javascript/V8/turbofan_transl/Abstract%20Syntax%20Tree.png">
<meta property="og:image" content="http://yoursite.com/images/Javascript/V8/turbofan_transl/Interpreter%20overview.png">
<meta property="og:image" content="http://yoursite.com/images/Javascript/V8/turbofan_transl/Runtime%20Semantics%20of%20the%20add%20operator.png">
<meta property="og:image" content="http://yoursite.com/images/Javascript/V8/turbofan_transl/ToPrimitive%20operation.png">
<meta property="og:image" content="http://yoursite.com/images/Javascript/V8/turbofan_transl/Closure%20structure.png">
<meta property="og:image" content="http://yoursite.com/images/Javascript/V8/turbofan_transl/Tagging%20Scheme.png">
<meta property="og:image" content="http://yoursite.com/images/Javascript/V8/turbofan_transl/Feedback%20Lattice.png">
<meta property="og:image" content="http://yoursite.com/images/Javascript/V8/turbofan_transl/TurboFan.png">
<meta property="og:image" content="http://yoursite.com/images/Javascript/V8/turbofan_transl/Generated%20assembly%20code.png">
<meta property="og:image" content="http://yoursite.com/images/Javascript/V8/turbofan_transl/Deoptimization%20example.png">
<meta property="article:published_time" content="2020-06-19T09:14:41.000Z">
<meta property="article:modified_time" content="2020-06-21T13:17:24.000Z">
<meta property="article:author" content="ma5ker">
<meta property="article:tag" content="V8">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/Javascript/V8/turbofan_transl/How%20V8%20Works.png">


<link rel="canonical" href="http://yoursite.com/2020/06/19/v8TurboFan/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>V8中Speculative Optimization简介 | sec4fun</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">sec4fun</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Overview"><span class="nav-number">1.</span> <span class="nav-text">Overview</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Basic-Execution-Pipeline"><span class="nav-number">2.</span> <span class="nav-text">The Basic Execution Pipeline</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Speculative-Optimization"><span class="nav-number">3.</span> <span class="nav-text">Speculative Optimization</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Excurse-Value-Representation"><span class="nav-number">4.</span> <span class="nav-text">Excurse: Value Representation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Feedback-Lattice"><span class="nav-number">5.</span> <span class="nav-text">Feedback Lattice</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Optimization-Pipeline"><span class="nav-number">6.</span> <span class="nav-text">The Optimization Pipeline</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Making-progress"><span class="nav-number">7.</span> <span class="nav-text">Making progress</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Takeaway"><span class="nav-number">8.</span> <span class="nav-text">Takeaway</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ma5ker"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">ma5ker</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Ma5ker" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ma5ker" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kcahlb@gmail.com" title="E-Mail → mailto:kcahlb@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/19/v8TurboFan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="ma5ker">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sec4fun">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          V8中Speculative Optimization简介
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-19 17:14:41" itemprop="dateCreated datePublished" datetime="2020-06-19T17:14:41+08:00">2020-06-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-06-21 21:17:24" itemprop="dateModified" datetime="2020-06-21T21:17:24+08:00">2020-06-21</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%B8%8E%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/" itemprop="url" rel="index"><span itemprop="name">论文阅读与文章翻译</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>一篇关于v8 <code>TurboFan</code>文章的翻译，原文地址：<a target="_blank" rel="noopener" href="https://ponyfoo.com/articles/an-introduction-to-speculative-optimization-in-v8">An Introduction to Speculative Optimization in V8</a>。</p>
<span id="more"></span>

<p><em>原文地址：<a target="_blank" rel="noopener" href="https://ponyfoo.com/articles/an-introduction-to-speculative-optimization-in-v8">An Introduction to Speculative Optimization in V8</a></em></p>
<p><em>作者：Benedikt Meurer</em></p>
<p><em>2017年11月28日</em></p>
<p>我们希望撰写一篇引人入胜的底层文章，以期让您对V8的优化有所了解。</p>
<p>在JS Kongress上我的演讲<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=cvybnv79Sek">“Turbo Tan的故事”</a>（slides）之后，我想提供一些其他背景信息来介绍V8的优化编译器TurboFan的工作方式以及V8如何将JavaScript变成高度优化的机器代码。 对于演讲来说必须要求简短，导致省略了一些细节。 因此，我将利用这个机会来填补空白，尤其是V8如何收集和使用配置信息来执行推测性优化。</p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>在深入探讨TurboFan的工作原理之前，我将简要介绍V8的工作原理。 让我们看一下V8的工作流程简要过程（摘自我的同事Addy Osmani的<a target="_blank" rel="noopener" href="https://medium.com/reloading/javascript-start-up-performance-69200f43b201">“JavaScript Start-up Performance”</a>博客文章）：</p>
<img src="/images/Javascript/V8/turbofan_transl/How V8 Works.png" alt="How V8 Works" style="zoom:50%;" />

<p>每当Chrome或Node.js必须执行一段JavaScript时，它将源代码传递给V8。 V8接收该JavaScript源代码并将其提供给所谓的Parser，后者将为源代码创建一个抽象语法树（AST）表示形式。 演讲<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Fg7niTmNNLg">“Parsing JavaScript — better lazy than eager?”</a> 来自我的同事MarjaHölttä的文章,其中包含有关V8如何工作的一些详细信息。 然后将AST传递到最近引入的Ignition解释器，在Ignition解释器中将其转换为字节码序列，然后由Ignition执行字节码。</p>
<p>在执行期间，Ignition收集与某些特定操作相关的输入的性能分析信息(profiling information)或反馈(feedback)。反馈中的一些会被Ignition用来加快字节码的后续解释。比如，对于属性的访问(o.x),其中o始终具有相同的形状(即，对于v为字符串的o，您始终传递值{x：v})，我们会缓存有关如何获取x值的信息。在随后执行相同的字节码时，我们无需再次在o中搜索x。此处的基础机制称为内联缓存（IC）。 您可以在我的同事维亚切斯拉夫·埃格罗夫（Vyacheslav Egorov）的博客文章<a target="_blank" rel="noopener" href="http://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html">“What’s up with monomorphism?”</a>中找到许多有关此方法如何用于属性访问的详细信息。</p>
<p>甚至更重要的是-取决于您的工作量-Ignition解释器收集的反馈将由TurboFan JavaScript编译器以一种称为“Speculative Optimization”的技术来利用生成高度优化的机器代码。优化编译器在这里查看过去遇到的值类型，并假定接下来将遇到相同类型的值。这使TurboFan可以省去很多不需要处理的情况，这对于以最佳性能执行JavaScript极为重要。</p>
<h2 id="The-Basic-Execution-Pipeline"><a href="#The-Basic-Execution-Pipeline" class="headerlink" title="The Basic Execution Pipeline"></a>The Basic Execution Pipeline</h2><p>再考虑一下我演讲中的示例的简化版本，仅关注函数<code>add</code>以及V8如何执行该函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>如果您在Chrome DevTools控制台中运行此命令，则会看到它输出了预期的结果3：</p>
<img src="/images/Javascript/V8/turbofan_transl/Chrome DevTools.png" alt="Chrome DevTools" style="zoom:50%;" />

<p>我们来看看在V8引擎下发生了什么才真正获得这些结果。我们将针对<code>add</code>函数一步步看V8做了什么。如前所述，我们首先需要解析函数源代码，并将其转换为抽象语法树（AST）。这是由解析器完成的，您可以在d8 shell的Debug版本中使用<code>--print-ast</code>命令行标志查看V8内部生成的AST。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> out/Debug/d8 --print-ast add.js</span></span><br><span class="line">…</span><br><span class="line">--- AST ---</span><br><span class="line">FUNC at 12</span><br><span class="line">. KIND 0</span><br><span class="line">. SUSPEND COUNT 0</span><br><span class="line">. NAME &quot;add&quot;</span><br><span class="line">. PARAMS</span><br><span class="line">. . VAR (0x7fbd5e818210) (mode = VAR) &quot;x&quot;</span><br><span class="line">. . VAR (0x7fbd5e818240) (mode = VAR) &quot;y&quot;</span><br><span class="line">. RETURN at 23</span><br><span class="line">. . ADD at 32</span><br><span class="line">. . . VAR PROXY parameter[0] (0x7fbd5e818210) (mode = VAR) &quot;x&quot;</span><br><span class="line">. . . VAR PROXY parameter[1] (0x7fbd5e818240) (mode = VAR) &quot;y&quot;</span><br></pre></td></tr></table></figure>

<p>这种格式不是很容易理解，因此我们对其进行可视化。</p>
<img src="/images/Javascript/V8/turbofan_transl/Abstract Syntax Tree.png" alt="Abstract Syntax Tree" style="zoom:50%;" />

<p>最开始，<code>add</code>函数的代码被解析为树表示形式，一个子树用于参数声明，一个子树用于实际函数主体。在解析过程中，不可能分辨出哪个名称对应于程序中的哪个变量，这主要是由于有趣的var提升规则和JavaScript中的eval，以及其他一些原因。因此，对于每个名称，解析器最初都会创建所谓的<code>VAR PROXY</code>节点。后续的范围解析步骤将这些<code>VAR PROXY</code>节点连接到声明的<code>VAR</code>节点，或将其标记为全局或动态查找(具体取决于解析器是否已在周围范围之一中看到了eval表达式)。</p>
<p>完成此操作后，我们将拥有一个完整的AST，其中包含从中生成可执行字节码的所有必要信息。然后将AST传递给<code>BytecodeGenerator</code>，它是Ignition解释器的一部分，该解释器将按功能生成字节码。 您还可以使用带有d8 shell（或带有节点）的标志<code>--print-bytecode</code>来查看V8生成的字节码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> out/Debug/d8 --print-bytecode add.js</span></span><br><span class="line">…</span><br><span class="line">[generated bytecode for function: add]</span><br><span class="line">Parameter count 3</span><br><span class="line">Frame size 0</span><br><span class="line">   12 E&gt; 0x37738712a02a @    0 : 94                StackCheck</span><br><span class="line">   23 S&gt; 0x37738712a02b @    1 : 1d 02             Ldar a1</span><br><span class="line">   32 E&gt; 0x37738712a02d @    3 : 29 03 00          Add a0, [0]</span><br><span class="line">   36 S&gt; 0x37738712a030 @    6 : 98                Return</span><br><span class="line">Constant pool (size = 0)</span><br><span class="line">Handler Table (size = 16)</span><br></pre></td></tr></table></figure>

<p>这告诉我们为函数<code>add</code>生成了一个新的字节码对象，该对象接受三个参数：隐式接收者this和显式形式参数x和y 该函数不需要任何局部变量（帧大小为零），并且包含四个字节码的序列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StackCheck</span><br><span class="line">Ldar a1</span><br><span class="line">Add a0, [0]</span><br><span class="line">Return</span><br></pre></td></tr></table></figure>

<p>为了解释这一点，我们首先需要了解解释器是如何工作在高级层面。Ignition使用了一个被称为<code>register machine</code>的技术(与早期V8版本中<code>FullCodegen</code>编译器使用的<code>stack machine</code>不同)。它会再解释寄存器中保存它的本地状态，其中一些会被映射到真实的CPU寄存器，另外一些则会映射到本机堆栈内存中的特定插槽。</p>
<img src="/images/Javascript/V8/turbofan_transl/Interpreter overview.png" alt="Interpreter overview" style="zoom:50%;" />

<p>特殊寄存器<code>a0</code>和<code>a1</code>与机器栈上的形参相对应(这个例子中有两个形参)。形参指的是源代码中定义的参数，可能与运行时传递给函数的参数数量不同。每个字节码最后被计算的值通常会被保留在一个特殊的寄存器<code>accumulator</code>，当前的<code>stack frame</code>或者<code>activation record</code>通过<code>stack pointer</code>识别，<code>program counter</code>指向字节码中当前执行指令。我们检查下再这个例子中独立的字节码做了什么：</p>
<ul>
<li><code>StackCheck</code>将<code>stack pointer</code>与一些已知的上限(实际上是下限因为在V8支持的所有架构中栈都是向下增长)。如果栈增长超过了阈值，我们中止执行函数并且抛出<code>RangeError</code>表示栈溢出。</li>
<li><code>Ldar a1</code>将寄存器<code>a1</code>的值加载进<code>accumulator</code>寄存器(名称表示<code>LoaD Accumulator Register</code>)。</li>
<li><code>Add a0, [0]</code>从<code>a0</code>寄存器加载值，将其与<code>accumulator</code>相加，并将结果放回<code>accumulator</code>。注意这里的<em>addition</em>也可以是字符串拼接，并且这个操作可以执行任意的javascript，主要取决于操作数类型。javascript中的<code>+</code>操作真的很复杂，许多人尝试在演讲中阐述其复杂性。<code>add</code>操作符的<code>[0]</code>操作数涉及到<code>feedback vector slot</code>，Ignition在其中保存关于值在之前已经见到的执行中的性能信息。我们后面观察 TurboFan优化函数时会回到这一点。</li>
<li><code>Return</code>结束当前函数的执行并将控制返回给调用者。返回值是当前<code>accumulator</code>寄存器中保存的值。</li>
</ul>
<h2 id="Speculative-Optimization"><a href="#Speculative-Optimization" class="headerlink" title="Speculative Optimization"></a>Speculative Optimization</h2><p>现在你已经对V8在基准情况下如何执行JavaScript有了一个大概的了解，是时候开始研究TurboFan如何融入这个框架，以及如何将JavaScript代码转换为高度优化的机器代码了。 在JavaScript中，+运算符已经是一个非常复杂的操作，在最终对输入进行加号之前，必须进行大量检查。</p>
<img src="/images/Javascript/V8/turbofan_transl/Runtime Semantics of the add operator.png" alt="Runtime Semantics of the + operator" style="zoom:50%;" />

<p>如何仅仅通过几条机器指令就可以达到高性能(相比<code>java</code>与<code>c++</code>代码)还不是很明显。这里的关键是<code>Speculative Optimization</code>，它利用了有关可能输入的假设。例如，当我们知道<code>x + y</code>中，x和y都是数字，则无需处理其中两个都是字符串甚至更糟的情况-操作数可以是任意JavaScript对象，这时我们必须先执行抽象操作<code>ToPrimitive</code>。</p>
<img src="/images/Javascript/V8/turbofan_transl/ToPrimitive operation.png" alt="ToPrimitive operation" style="zoom:50%;" />

<p>知道x和y都是数字，这也意味着我们可以排除明显的副作用-例如，我们知道它无法关闭计算机或写入文件或导航到其他页面。此外，我们知道该操作不会引发异常。两者对于优化都是很重要的，因为优化编译器只有在确定该表达式不会引起任何可观察到的副作用并且不会引发异常的情况下，才能消除该表达式。</p>
<p>由于JavaScript的动态性质，通常在运行时我们才知道值的确切类型，即仅通过查看源代码，通常就无法确定操作输入的可能值。因此，我们需要根据以前收集的有关到目前为止所见值的反馈来进行推测，然后假设我们将来始终看到相似的值。这听起来可能相当有限，但是事实证明，它对于像JavaScript这样的动态语言都适用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个特殊例子下，我们收集有关输入操作数和<code>+</code>运算符的结果值（add字节码）的信息。当我们使用TurboFan优化此代码时，到目前为止，我们只看到数字，我们进行了检查以确保x和y均为数字（在这种情况下，我们知道结果也将是数字）。如果这些检查中的任何一项失败，我们都将转回解释字节码，即称为”Deoptimization”的过程。因此，TurboFan不必担心<code>+</code>运算符的所有其他情况，甚至不需要机器代码来处理这些情况，而是可以专注于数字的情况，这可以很好地转化为机器指令。</p>
<img src="/images/Javascript/V8/turbofan_transl/Closure structure.png" alt="Closure structure" style="zoom:50%;" />

<p>由Ignition收集的反馈存储在所谓的<code>Feedback Vector</code>（以前称为<code>Type Feedback Vector</code>）中。这种特殊的数据结构从闭包开始链接，并包含一些<code>slot</code>用于存储不同类型的反馈，即位集，闭包或隐藏类，取决于具体的内联缓存（IC）。该闭包还链接到<code>SharedFunctionInfo</code>，其中包含有关该功能的常规信息（例如源代码位置，字节码，strict/sloppy模式等），并且还有一个指向上下文的链接，其中包含函数中自由变量的值，并提供对全局对象（即<code>&lt;iframe&gt;</code>特定数据结构）的访问。</p>
<p>在使用add函数的情况下，<code>Feedback Vector</code>恰好有一个有趣的<code>slot</code>(除了通常的调用计数器<code>slot</code>外)，叫做<code>BinaryOp slot</code>，二进制操作如<code>+ - *</code>等可以存放之前见到的关于输入与输出的<code>feedback</code>。可以通过在运行时使用<code>--allow-natives-syntax</code>命令行标识使用特殊的<code>%DebugPrint()</code>内部函数来查看<code>feedback</code>的内部有什么(在构建的Debug版本的d8中)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">%DebugPrint(add);</span><br></pre></td></tr></table></figure>

<p>在d8中运行并使用<code>--allow-natives-syntax</code>标识可以观察到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ out&#x2F;Debug&#x2F;d8 --allow-natives-syntax add.js</span><br><span class="line">DebugPrint: 0xb5101ea9d89: [Function] in OldSpace</span><br><span class="line">…</span><br><span class="line"> - feedback vector: 0xb5101eaa091: [FeedbackVector] in OldSpace</span><br><span class="line"> - length: 1</span><br><span class="line"> SharedFunctionInfo: 0xb5101ea99c9 &lt;SharedFunctionInfo add&gt;</span><br><span class="line"> Optimized Code: 0</span><br><span class="line"> Invocation Count: 1</span><br><span class="line"> Profiler Ticks: 0</span><br><span class="line"> Slot #0 BinaryOp BinaryOp:SignedSmall</span><br><span class="line">…</span><br></pre></td></tr></table></figure>

<p>可以看到<code>invocation count</code>是1，因为我们只运行了<code>add</code>函数一次。当然目前也没有优化代码(Optimized Code: 0可以看出)。但是<code>feedback vector</code>中有一个<code>slot</code>,是一个<code>BinaryOp slot</code>，其当前<code>feedback</code>是<code>SignedSmall</code>。这意味着什么？涉及到<code>feedback slot 0</code>的<code>Add</code>的字节码目前只看到了输入类型为<code>SignedSmall</code>并且只产生了<code>SignedSmall</code>类型的输出。</p>
<p>但是<code>SignedSmall</code>类型是什么？Javascript并没有这个名字的类型。这个名字来自于当表示<code>small signed integer</code>值时V8中所做的优化，这个在程序出现的足够频繁值得被特殊对待(其他的javascript引擎有相似的优化)。</p>
<h2 id="Excurse-Value-Representation"><a href="#Excurse-Value-Representation" class="headerlink" title="Excurse: Value Representation"></a>Excurse: Value Representation</h2><p>我们简单的探究下javascript值是如何在V8中表示以更好的理解后面的概念。大体上V8使用了一个称为<code>Pointer Tagging</code>的技术去表示值。我们处理的大多数值存在于Javascript堆中，并由garbage collector (GC)管理。但是对于一些值，总是在内存中申请他们会非常浪费。特别是经常用于数组索引的小整形值和暂时的计算结果。</p>
<img src="/images/Javascript/V8/turbofan_transl/Tagging Scheme.png" alt="Tagging Scheme" style="zoom:50%;" />

<p>在V8中，有两个可能的<code>tagged representations</code>:<code>Smi</code>(<em>Small Integer</em>)和指向内存管理堆的<code>HeapObject</code>。我们基于一个事实：所有申请的对象都是word对齐的(64-bit或者32-bit取决于架构)，这意味着最低的2或者3位有效位总是0。我们使用最低有效位区分<code>HeapObject</code>(位为1)和<code>Smi</code>(位为0)。对于64位架构的<code>Smi</code>最低的32位总是0，带符号的32-bit值被存放在word的高位那半部分。这使得可以使用单一机器指令高效的获取内存的32-bit值而不用将其加载或者移位，也因为32位算术对于JavaScript中的按位运算很常见。</p>
<p>在32位体系结构上，<code>Smi</code>表示的最低有效位设置为0，带符号的31位值向左移一位，该值存储在该字的高31位中。</p>
<h2 id="Feedback-Lattice"><a href="#Feedback-Lattice" class="headerlink" title="Feedback Lattice"></a>Feedback Lattice</h2><p><code>SignedSmall</code>反馈类型涉及到所有拥有<code>Smi</code>表示的值。对于<code>Add</code>操作它意味着目前仅见到输入被表示为<code>Smi</code>，并且产生的输出也能被表示为<code>Smi</code>(即值不会溢出32位整型值得范围)。我们看下如果我们调用<code>add</code>并传入其他不能被表示为<code>Smi</code>的数会发生什么。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1.1</span>, <span class="number">2.2</span>));</span><br><span class="line">%DebugPrint(add);</span><br></pre></td></tr></table></figure>

<p>再次使用<code>--allow-natives-syntax</code>在d8运行可以观察到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ out&#x2F;Debug&#x2F;d8 --allow-natives-syntax add.js</span><br><span class="line">DebugPrint: 0xb5101ea9d89: [Function] in OldSpace</span><br><span class="line">…</span><br><span class="line"> - feedback vector: 0x3fd6ea9ef9: [FeedbackVector] in OldSpace</span><br><span class="line"> - length: 1</span><br><span class="line"> SharedFunctionInfo: 0x3fd6ea9989 &lt;SharedFunctionInfo add&gt;</span><br><span class="line"> Optimized Code: 0</span><br><span class="line"> Invocation Count: 2</span><br><span class="line"> Profiler Ticks: 0</span><br><span class="line"> Slot #0 BinaryOp BinaryOp:Number</span><br><span class="line">…</span><br></pre></td></tr></table></figure>

<p>首先，我们可以看到<code>invocation count</code>现在是2，因为我们运行了函数两次。并且可以看到<code>BinaryOp slot</code>转为<code>Number</code>，这表示我们看到了操作数为任意数(即非整型值)。此外，还有一些可能的反馈状态，大致如下所示：</p>
<img src="/images/Javascript/V8/turbofan_transl/Feedback Lattice.png" alt="Feedback Lattice" style="zoom:50%;" />

<p>反馈状态以None开始，这表示我们目前没见到任何东西，所有什么都不知道。<code>Any</code>状态表示我们已经见到不兼容的输入或输出的组合。<code>Any</code>状态也表示<code>Add</code>应当被考虑为<code>多态(polymorphic)</code>。相反的，保留状态表示<code>Add</code>是单态的(monomorphic)，因为它已经看到并且产生几乎相同的值。</p>
<ul>
<li><code>SignedSmall</code>表示所有的值都是小整型(有符号32-bit或31-bit，取决于架构)，并且所有的值都可以被表示为<code>Smi</code>。</li>
<li><code>Number</code>表示所有的值都是常规数(这也包括了<code>SignedSmall</code>)。</li>
<li><code>NumberOrOddball</code>表示所有的值都来自<code>Number</code>加上<code>undefined</code>,<code>null</code>,<code>true</code>和<code>false</code>。</li>
<li><code>String</code>表示所有的输入都是字符串值。</li>
<li><code>BigInt</code>表示所有的输入都是<code>BigInts</code>。</li>
</ul>
<p>重要的是要注意，反馈只能在这个网格中进行，永远都不会回头。如果回头，那就有可能进入所谓的非优化循环<code>deoptimization loop</code>，在该循环中，优化编译器会消耗反馈，并在发现与反馈不一致的值时退出优化代码（返回解释器）。下一次函数变成热点后最终将对其进行再次优化。因此，如果我们不在网格中继续前进，那么TurboFan将再次生成相同的代码，这实际上意味着它将再次接受相同类型的输入。因此，引擎将忙于仅优化和取消优化代码，而不是高速运行JavaScript代码。</p>
<h2 id="The-Optimization-Pipeline"><a href="#The-Optimization-Pipeline" class="headerlink" title="The Optimization Pipeline"></a>The Optimization Pipeline</h2><p>现在我们知道了Ignition如何收集<code>add</code>函数的反馈，下面我们看下TurboFan如何使用feedback去生成最小化代码。我将使用内部函数<code>%OptimizeFunctionOnNextCall()</code>去在一个特殊的时间点触发函数优化。我们经常使用这些内部函数来通过特殊的方式去写测试来测试机器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// Warm up with SignedSmall feedback.</span></span><br><span class="line">%OptimizeFunctionOnNextCall(add);</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// Optimize and run generated code.</span></span><br></pre></td></tr></table></figure>

<p>这里我们先给<code>x+y</code>传入两个整型值，其和也在小整型范围，以此得到<code>SignedSmall</code>反馈。然后我们告诉V8下一次调用时应当优化<code>add</code>函数(使用TurboFan)，最后我们调用<code>add</code>，这将会触发<code>TurboFan</code>并执行生成的机器码。</p>
<img src="/images/Javascript/V8/turbofan_transl/TurboFan.png" alt="TurboFan" style="zoom:50%;" />

<p>TurboFan接受之前生成的<code>add</code>的字节码并从<code>add</code>的反馈向量中解w析出反馈。它将这些转化为图表示，并将图在前端、优化以及后端各个过程中传递。我不打算深入传递的细节，这是一个独立的博客主题。我们看一下生成的机器码并观察<code>speculative optimization</code>如何工作。你可以通过在d8中加入<code>--print-opt-code</code>查看TurboFan生成的代码。</p>
<img src="/images/Javascript/V8/turbofan_transl/Generated assembly code.png" alt="Generated assembly code" style="zoom:50%;" />

<p>这是TurboFan生成的x64机器码，并带有我的注释，忽略了一些不重要的技术细节(如Deoptimizer的精确调用序列)。我们看下代码做了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Prologue</span><br><span class="line">leaq rcx,[rip+0x0]</span><br><span class="line">movq rcx,[rcx-0x37]</span><br><span class="line">testb [rcx+0xf],0x1</span><br><span class="line">jnz CompileLazyDeoptimizedCode</span><br><span class="line">push rbp</span><br><span class="line">movq rbp,rsp</span><br><span class="line">push rsi</span><br><span class="line">push rdi</span><br><span class="line">cmpq rsp,[r13+0xdb0]</span><br><span class="line">jna StackCheck</span><br></pre></td></tr></table></figure>

<p><code>Prologue</code>检查代码对象是否仍然有效或者某些条件是否已经改变使得我们必须丢弃掉代码对象。一旦我们发现代码仍然有效，就构建<code>stack frame</code>并检查栈上是否有足够的剩余空间来执行代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Check x is a small integer</span><br><span class="line">movq rax,[rbp+0x18]</span><br><span class="line">test al,0x1</span><br><span class="line">jnz Deoptimize</span><br><span class="line"># Check y is a small integer</span><br><span class="line">movq rbx,[rbp+0x10]</span><br><span class="line">testb rbx,0x1</span><br><span class="line">jnz Deoptimize</span><br><span class="line"># Convert y from Smi to Word32</span><br><span class="line">movq rdx,rbx</span><br><span class="line">shrq rdx, 32</span><br><span class="line"># Convert x from Smi to Word32</span><br><span class="line">movq rcx,rax</span><br><span class="line">shrq rcx, 32</span><br></pre></td></tr></table></figure>

<p>然后我们开始执行函数体。我们从栈上加载参数x和y的值(与帧指针<code>rbp</code>相似)并且检测两个值是否都是用<code>Smi</code>表示(因为<code>+</code>操作的反馈告诉我们之前的所有的输入总是<code>Smi</code>)。这可以通过测试最低有效位来完成。一旦发现他们都是用<code>Smi</code>表示，我们就需要将他们转换为32表示(通过将值右移32位)。</p>
<p>如果x和y中有一个不是<code>Smi</code>，优化代码会立即停止执行，然后<code>Deoptimizer</code>会在<code>Add</code>之前在解释器中恢复函数的状态。</p>
<p>注意：我们也可以在此处对Smi表示进行加操作； 这就是我们之前优化的编译器Crankshaft所做的。 这样可以节省我们的时间，但是目前TurboFan尚无法很好地确定在Smi上进行操作是否有益，因为这并不总是理想的选择，并且在很大程度上取决于使用此操作的环境。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Add x and y (incl. overflow check)</span><br><span class="line">addl rdx,rcx</span><br><span class="line">jo Deoptimize</span><br><span class="line"># Convert result to Smi</span><br><span class="line">shlq rdx, 32</span><br><span class="line">movq rax,rdx</span><br><span class="line"># Epilogue</span><br><span class="line">movq rsp,rbp</span><br><span class="line">pop rbp</span><br><span class="line">ret 0x18</span><br></pre></td></tr></table></figure>

<p>然后我们继续对输入整型进行加操作。我们需要明确地检查溢出，因为相加的结果可能会超出32位整型范围，这时我们就要返回到解释器，解释器会学习到<code>Add</code>的<code>Number</code>反馈。最后我们通过移位操作传出<code>Smi</code>表示的结果，并将结果返回到<code>rax</code>。</p>
<p>如前所述，对于这种情况，这不是完美的代码，因为在这里直接在Smi表示上执行加法更好，而不是使用Word32，这将为我们节省三个移位指令。但是，抛开了这一次要方面，您可以看到生成的代码是经过高度优化的，并且专门用于性能分析反馈。在这里，它甚至不尝试处理其他数字，字符串，大整数或任意JavaScript对象，而仅关注到目前为止我们所看到类型的值。这是使得许多JavaScript应用程序达到最佳性能的关键因素。</p>
<h2 id="Making-progress"><a href="#Making-progress" class="headerlink" title="Making progress"></a>Making progress</h2><p>那么如果你突然改变主意想将两个数字相加呢？我们改变一下例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// Warm up with SignedSmall feedback.</span></span><br><span class="line">%OptimizeFunctionOnNextCall(add);</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// Optimize and run generated code.</span></span><br><span class="line">add(<span class="number">1.1</span>, <span class="number">2.2</span>); <span class="comment">// Oops?!</span></span><br></pre></td></tr></table></figure>

<p>用<code>--allow-natives-syntax</code>和<code>--trace-deopt</code>参数运行，观测如下：</p>
<img src="/images/Javascript/V8/turbofan_transl/Deoptimization example.png" alt="Deoptimization example" style="zoom:50%;" />

<p>输出很多，我们提取一下重要的部分。首先，我们打印出必须进行<code>deoptimize</code>的原因，在这种情况下，它不是Smi，这意味着我们假设值是Smi，但现在我们看到了HeapObject。 确实，rax中的值应该是Smi，但结果是数字1.1。因此，我们在第一次检查x参数时失败了，我们需要取消优化以返回到解释字节码。不过这是另一篇文章的主题。</p>
<h2 id="Takeaway"><a href="#Takeaway" class="headerlink" title="Takeaway"></a>Takeaway</h2><p>我希望你喜欢本文关于V8中<code>Speculative Optimization</code>如何工作以及它如何帮助我们达到JavaScript应用程序的最佳性能的挖掘。不过，不要太担心这些细节。在用JavaScript编写应用程序时，应着重于应用程序设计，并确保使用适当的数据结构和算法。尽管编写惯用的JavaScript，让我们去担心底层的JavaScript性能。如果你发现某件事不该慢的代码太慢，请提交错误报告，以便我们有机会对此进行调查。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/V8/" rel="tag"># V8</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/06/14/happyheap/" rel="prev" title="堆溢出(3)-堆攻击手法">
                  <i class="fa fa-chevron-left"></i> 堆溢出(3)-堆攻击手法
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/06/21/hexoConfig/" rel="next" title="关于hexo配置的一些记录">
                  关于hexo配置的一些记录 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ma5ker</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">270k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:05</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  















  








  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css">

<script>
NexT.utils.loadComments('#gitalk-container', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '0530768cd3819c29f055',
      clientSecret: '9465920674abd65e54adf115c57771a78911b8f4',
      repo        : 'blog-comments',
      owner       : 'Ma5ker',
      admin       : ['Ma5ker'],
      id          : 'a2f1b466f5efff750d96f8e04df9fd43',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":85,"height":200,"hOffset":60,"vOffset":40},"mobile":{"show":true,"scale":0.3,"motion":true},"neat_enable":true,"neat_html":{"enable":true,"exclude":null},"neat_css":{"enable":true,"exclude":["**/*.min.css"]},"neat_js":{"enable":true,"mangle":true,"output":null,"compress":null,"exclude":["**/*.min.js","**/jquery.fancybox.pack.js","**/index.js","**/love.js"]},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
